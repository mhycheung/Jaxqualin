{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"A python package for extracting quasinormal modes from black-hole ringdown simulations."},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Fit a ringdown waveform with quasinormal modes (QNMs) of fixed or free frequencies</li> <li>Nonlinear least-squares fitting with automatic differentiation via JaxFit</li> <li>Agnostic identification of QNMs within the waveform</li> <li>Saving and reusing results with <code>pickle</code></li> <li>Easy visualization of results</li> <li>Call hyperfit polynomials to approximate QNM amplitudes in the ringdown of binary black hole (BBH) mergers</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install jaxqualin\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Basic usage examples can be found under the Examples tab on the left.</p> <p>Note We did not extensively test and do not recommend running <code>jaxqualin</code> on a GPU</p>"},{"location":"#paper-results","title":"Paper Results","text":"<p>Interactive plots of the methods paper results can be found under the Results tab on the left.</p>"},{"location":"#coming-soon","title":"Coming Soon","text":"<ul> <li>Full API</li> <li>Support for real (Schwarzshild) ringdown waveforms</li> <li>Fitting for the mass and spin of the remnant</li> <li>Fitting the (noiseless) detector response </li> </ul>"},{"location":"#how-to-cite","title":"How to Cite","text":"<p>Please cite the methods paper if you used our package to produce results in your publication. Here is the BibTeX entry:</p> <pre><code>@misc{cheung2023extracting,\n      title={Extracting linear and nonlinear quasinormal\n      modes from black hole merger simulations}, \n      author={Mark Ho-Yeuk Cheung and Emanuele Berti and \n      Vishal Baibhav and Roberto Cotesta},\n      year={2023},\n      eprint={2310.04489},\n      archivePrefix={arXiv},\n      primaryClass={gr-qc}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT</p> <p>GitHub @mhycheung</p>"},{"location":"data/","title":"Download data","text":""},{"location":"data/#hyperfit-functions","title":"Hyperfit functions","text":"<p>Hyperfit functions</p>"},{"location":"data/#interpolation-data","title":"Interpolation data","text":"<p>Interpolation data</p>"},{"location":"data/#complete-mode-extraction-results","title":"Complete mode extraction results","text":"<p>Full results</p>"},{"location":"paper-results/","title":"Results for paper","text":""},{"location":"paper-results/#220-mode","title":"2,2,0 mode","text":"\\[ 4.061 + 0.4761 \\chi_- - 7.838 \\eta^2 + 21.4 \\eta \\chi_+ - 1.946 \\eta \\chi_- + 0.869 \\chi_+^2 + 22.56 \\eta^3 - 146.4 \\eta^2 \\chi_+ + 282.4 \\eta^3 \\chi_+ - 10.36 \\eta^2 \\chi_+^2 - 0.441 \\eta \\chi_+^3 - 0.2067 \\chi_+^4 - 0.2864 \\chi_+^2 \\chi_-^2 + 4.061 + 0.4761 \\chi_- - 7.838 \\eta^2 + 21.4 \\eta \\chi_+ - 1.946 \\eta \\chi_- + 0.869 \\chi_+^2 + 22.56 \\eta^3 - 146.4 \\eta^2 \\chi_+ + 282.4 \\eta^3 \\chi_+ - 10.36 \\eta^2 \\chi_+^2 - 0.441 \\eta \\chi_+^3 - 0.2067 \\chi_+^4 - 0.2864 \\chi_+^2 \\chi_-^2 + 4.061 + 0.4761 \\chi_- - 7.838 \\eta^2 + 21.4 \\eta \\chi_+ - 1.946 \\eta \\chi_- + 0.869 \\chi_+^2 + 22.56 \\eta^3 - 146.4 \\eta^2 \\chi_+ + 282.4 \\eta^3 \\chi_+ - 10.36 \\eta^2 \\chi_+^2 - 0.441 \\eta \\chi_+^3 - 0.2067 \\chi_+^4 - 0.2864 \\chi_+^2 \\chi_-^2 + 4.061 + 0.4761 \\chi_- - 7.838 \\eta^2 + 21.4 \\eta \\chi_+ - 1.946 \\eta \\chi_- + 0.869 \\chi_+^2 + 22.56 \\eta^3 - 146.4 \\eta^2 \\chi_+ + 282.4 \\eta^3 \\chi_+ - 10.36 \\eta^2 \\chi_+^2 - 0.441 \\eta \\chi_+^3 - 0.2067 \\chi_+^4 - 0.2864 \\chi_+^2 \\chi_-^2 \\]"},{"location":"paper-results/#221-mode","title":"2,2,1 mode","text":""},{"location":"paper-results/#210-mode","title":"2,1,0 mode","text":""},{"location":"paper-results/#211-mode","title":"2,1,1 mode","text":""},{"location":"paper-results/#330-mode","title":"3,3,0 mode","text":""},{"location":"paper-results/#331-mode","title":"3,3,1 mode","text":""},{"location":"paper-results/#320-mode","title":"3,2,0 mode","text":""},{"location":"paper-results/#440-mode","title":"4,4,0 mode","text":""},{"location":"paper-results/#550-mode","title":"5,5,0 mode","text":""},{"location":"paper-results/#r220-mode","title":"r2,2,0 mode","text":""},{"location":"paper-results/#r210-mode","title":"r2,1,0 mode","text":""},{"location":"references/","title":"References","text":""},{"location":"references/#jaxqualin.data","title":"<code>data</code>","text":""},{"location":"references/#jaxqualin.data.download_file","title":"<code>download_file(filepath, url, overwrite='update')</code>","text":"<p>Downloads a file from a url to a filepath</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath to save the downloaded file to</p> required <code>url</code> <code>str</code> <p>The url to download the file from</p> required <code>overwrite</code> <code>str</code> <p>Whether to overwrite the file if it already exists. Can be one of 'force', 'update', or 'never'.</p> <code>'update'</code>"},{"location":"references/#jaxqualin.data.last_modified_time","title":"<code>last_modified_time(url)</code>","text":"<p>Returns the last modified time of a url</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to check the last modified time of</p> required <p>Returns:</p> Type Description <code>struct_time</code> <p>The last modified time of the url as a time.struct_time object</p>"},{"location":"references/#jaxqualin.data.make_hyper_fit_functions","title":"<code>make_hyper_fit_functions(filepath=_default_hyperfit_data_path, PN=True)</code>","text":"<p>Make a dictionary of hyperfit functions from a hyperfit data file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath of the hyperfit data file.</p> <code>_default_hyperfit_data_path</code> <code>PN</code> <code>bool</code> <p>Whether to use Post Newtonian variables (<code>eta</code>, <code>chi_p</code>, <code>chi_m</code>) or the natural parameterization of the BBH simulations (<code>q</code>, <code>chi_1</code>, <code>chi_2</code>).</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Callable[[float, float, float], float]]]</code> <p>A dictionary of hyperfit functions. The keys are the mode names, and the values are dictionaries with keys <code>A</code> and <code>phi</code> for the amplitude and phase hyperfit functions, respectively.</p>"},{"location":"references/#jaxqualin.data.make_interpolators","title":"<code>make_interpolators(filepath=_default_interpolate_data_path, PN=True)</code>","text":"<p>Make a dictionary of interpolators from a data file containing the extracted amplitude and phases of different modes from BBH simulations.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath of the data file.</p> <code>_default_interpolate_data_path</code> <code>PN</code> <code>bool</code> <p>Whether to use Post Newtonian variables (<code>eta</code>, <code>chi_p</code>, <code>chi_m</code>) or the natural parameterization of the BBH simulations (<code>q</code>, <code>chi_1</code>, <code>chi_2</code>).</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, LinearNDInterpolator]]</code> <p>A dictionary of interpolators. The keys are the mode names, and the values are dictionaries with keys <code>A</code>, <code>dA</code>, <code>phi</code>, and <code>dphi</code> for the amplitude, amplitude fluctuation, phase, and phase fluctuation interpolators, respectively.</p>"},{"location":"references/#jaxqualin.fit","title":"<code>fit</code>","text":""},{"location":"references/#jaxqualin.fit.QNMFitVaryingStartingTime","title":"<code>QNMFitVaryingStartingTime</code>","text":"<p>A class for fitting the postmerger waveform with a varying starting time.</p> <p>Attributes:</p> Name Type Description <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting. </p> <code>h</code> <code>waveform</code> <p>waveform object to be fitted. </p> <code>var_M_a</code> <code>bool</code> <p>fit for the mass and spin of the black hole. </p> <code>Warning</code> <code>bool</code> <p>Not tested yet.</p> <code>Schwarzschild</code> <code>bool</code> <p>whether to fit for Schwarzschild black hole, i.e. real waveform.</p> <code>N_free</code> <code>int</code> <p>number of frequency-free QNMs to include in the model. These modes are completely free, i.e. their mode numbers are not fixed like those in <code>qnm_free_list</code>.</p> <code>qnm_fixed_list</code> <code>List[mode]</code> <p>list of fixed-frequency QNMs included in the model.</p> <code>qnm_free_list</code> <code>List[mode_free]</code> <p>list of free-frequency QNMs of fixed mode numbers to include in the model, only used for fitting <code>M</code> and <code>a</code> when <code>var_M_a = True</code>.</p> <code>N_free</code> <code>int</code> <p>number of free QNMs. </p> <code>run_string_prefix</code> <code>str</code> <p>prefix of the run name for dumping the <code>pickle</code> file.</p> <code>nonconvergence_cut</code> <code>bool</code> <p>whether to cut the nonconverged fits.</p> <code>nonconvergence_indx</code> <code>List[int]</code> <p>indices of the nonconverged fits. </p> <code>initial_num</code> <code>int</code> <p>number of initial guesses to use for the first starting time for frequency-free fits.</p> <code>include_mirror</code> <code>bool</code> <p>whether to include the mirror modes, for fitting waveforms with both waveform polarizations.</p> <code>mirror_ratio_list</code> <code>List[float]</code> <p>list of ratios between prograde and mirror mode amplitudes.</p> <code>iota</code> <code>float</code> <p>inclination angle of the source. </p> <code>psi</code> <code>float</code> <p>polarization angle of the source. </p> <code>save_results</code> <code>bool</code> <p>whether to save the results. </p> <code>params0</code> <code>ndarray</code> <p>initial guess for the fit parameters, at least for the earliest <code>t0</code> fit.</p> <code>max_nfev</code> <code>int</code> <p>maximum number of function evaluations for the fit.</p> <code>sequential_guess</code> <code>bool</code> <p>whether to use the previous fit as the initial guess for the next fit.</p> <code>load_pickle</code> <code>bool</code> <p>whether to load the <code>pickle</code> file if it exists.</p> <code>fit_save_prefix</code> <code>str</code> <p>prefix of the path to save the <code>pickle</code> file. </p> <code>A_bound</code> <code>float</code> <p>maximum value of the amplitude. </p> <code>jcf</code> <code>CurveFit</code> <p><code>jaxfit</code> curve fit object.</p> <code>fit_kwargs</code> <code>Dict[str, Any]</code> <p>keyword arguments for the <code>jcf.curve_fit</code> method.</p> <code>initial_dict</code> <code>Dict[str, Any]</code> <p>key word arguments for <code>make_initial_guess</code> method.</p> <code>A_guess_relative</code> <code>bool</code> <p>whether to multiply the initial guess of the amplitude by the peak strain of the waveform.</p> <code>set_seed</code> <code>int</code> <p>random seed for generating the initial guesses. </p> <code>weighted</code> <code>bool</code> <p>whether to perform a weighted fit. </p> <code>double_skip</code> <code>bool</code> <p>whether to skip the next <code>2^n</code> <code>t0</code> fits when a fit does not converge, where <code>n</code> is the number of times the fit did not converge consecutively.</p> <code>skip_i_init</code> <code>int</code> <p>number of <code>t0</code> fits to skip for the first time a nonconvergent fit occured.</p> <code>result_full</code> <code>QNMFitVaryingStartingTimeResult</code> <p><code>QNMFitVaryingStartingTimeResult</code> object for storing the fit results.</p> <p>Methods:</p> Name Description <code>get_mirror_ratio_list</code> <p>get <code>mirror_ratio_list</code> from <code>iota</code> and <code>psi</code>.</p> <code>initial_guesses</code> <p>generate initial guesses for the first <code>t0</code> fit.</p> <code>make_nan_result</code> <p>generate a <code>QNMFitVaryingStartingTimeResult</code> object</p> <code>with `nan` values. do_fits</code> <p>perform the fits.</p>"},{"location":"references/#jaxqualin.fit.QNMFitVaryingStartingTime.__init__","title":"<code>__init__(h, t0_arr, N_free=0, qnm_fixed_list=[], qnm_free_list=[], var_M_a=False, Schwarzschild=False, run_string_prefix='Default', params0=None, max_nfev=200000, sequential_guess=True, load_pickle=True, fit_save_prefix=FIT_SAVE_PATH, nonconvergence_cut=False, A_bound=np.inf, jcf=None, fit_kwargs={}, initial_num=1, random_initial=False, initial_dict={}, A_guess_relative=True, set_seed=1234, weighted=False, double_skip=True, include_mirror=False, iota=None, psi=None, mirror_ignore_phase=True, skip_i_init=1, save_results=True)</code>","text":"<p>Initialize the <code>QNMFitVaryingStartingTime</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>waveform</code> <p>waveform object to be fitted.</p> required <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting.</p> required <code>N_free</code> <code>int</code> <p>number of frequency-free QNMs to include in the model. These modes are completely free, i.e. their mode numbers are not fixed like those in <code>qnm_free_list</code>.</p> <code>0</code> <code>qnm_fixed_list</code> <code>List[mode]</code> <p>list of fixed-frequency QNMs included in the model.</p> <code>[]</code> <code>qnm_free_list</code> <code>List[mode_free]</code> <p>list of free-frequency QNMs of fixed mode numbers to include in the model, only used for fitting <code>M</code> and <code>a</code> when <code>var_M_a = True</code>.</p> <code>[]</code> <code>var_M_a</code> <code>bool</code> <p>fit for the mass and spin of the black hole. Warning: Not tested yet.</p> <code>False</code> <code>Schwarzschild</code> <code>bool</code> <p>whether to fit for Schwarzschild black hole, i.e. real waveform.</p> <code>False</code> <code>run_string_prefix</code> <code>str</code> <p>prefix of the run name for dumping the <code>pickle</code> file.</p> <code>'Default'</code> <code>params0</code> <code>Optional[ndarray]</code> <p>initial guess for the fit parameters, at least for the earliest <code>t0</code> fit.</p> <code>None</code> <code>max_nfev</code> <code>int</code> <p>maximum number of function evaluations for the fit.</p> <code>200000</code> <code>sequential_guess</code> <code>bool</code> <p>whether to use the previous fit as the initial guess for the next fit.</p> <code>True</code> <code>load_pickle</code> <code>bool</code> <p>whether to load the <code>pickle</code> file if it exists.</p> <code>True</code> <code>fit_save_prefix</code> <code>str</code> <p>prefix of the path to save the <code>pickle</code> file.</p> <code>FIT_SAVE_PATH</code> <code>nonconvergence_cut</code> <code>bool</code> <p>whether to cut the nonconverged fits.</p> <code>False</code> <code>A_bound</code> <code>float</code> <p>maximum value of the amplitude.</p> <code>inf</code> <code>jcf</code> <code>Optional[CurveFit]</code> <p><code>jaxfit</code> curve fit object.</p> <code>None</code> <code>fit_kwargs</code> <code>Dict</code> <p>keyword arguments for the <code>jcf.curve_fit</code> method.</p> <code>{}</code> <code>initial_num</code> <code>int</code> <p>number of initial guesses to use for the first starting time for frequency-free fits.</p> <code>1</code> <code>random_initial</code> <code>bool</code> <p>whether to generate random initial guesses for the first starting time for frequency-free fits.</p> <code>False</code> <code>initial_dict</code> <code>Dict</code> <p>key word arguments for <code>make_initial_guess</code> method.</p> <code>{}</code> <code>A_guess_relative</code> <code>bool</code> <p>whether to multiply the initial guess of the amplitude by the peak strain of the waveform.</p> <code>True</code> <code>set_seed</code> <code>int</code> <p>random seed for generating the initial guesses.</p> <code>1234</code> <code>weighted</code> <code>bool</code> <p>whether to perform a weighted fit.</p> <code>False</code> <code>double_skip</code> <code>bool</code> <p>whether to skip the next <code>2^n</code> <code>t0</code> fits when a fit does not converge, where <code>n</code> is the number of times the fit did not converge consecutively.</p> <code>True</code> <code>include_mirror</code> <code>bool</code> <p>whether to include the mirror modes, for fitting waveforms with both waveform polarizations.</p> <code>False</code> <code>iota</code> <code>Optional[float]</code> <p>inclination angle of the source.</p> <code>None</code> <code>psi</code> <code>Optional[float]</code> <p>polarization angle of the source.</p> <code>None</code> <code>mirror_ignore_phase</code> <code>bool</code> <p>whether to ignore the phase difference between the prograde and mirror modes.</p> <code>True</code> <code>skip_i_init</code> <code>int</code> <p>number of <code>t0</code> fits to skip for the first time a nonconvergent fit occured.</p> <code>1</code> <code>save_results</code> <code>bool</code> <p>whether to save the results.</p> <code>True</code>"},{"location":"references/#jaxqualin.fit.QNMFitVaryingStartingTime.do_fits","title":"<code>do_fits(jcf=None, return_jcf=False)</code>","text":"<p>Perform the fits.</p> <p>Parameters:</p> Name Type Description Default <code>jcf</code> <code>Optional[CurveFit]</code> <p><code>jaxfit</code> curve fit object.</p> <code>None</code> <code>return_jcf</code> <code>bool</code> <p>whether to return the <code>jaxfit</code> curve fit object.</p> <code>False</code>"},{"location":"references/#jaxqualin.fit.QNMFitVaryingStartingTime.get_mirror_ratio_list","title":"<code>get_mirror_ratio_list()</code>","text":"<p>Get the ratios between the prograde and mirror modes from <code>iota</code> and <code>psi</code>.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>list of ratios between prograde and mirror mode amplitudes.</p>"},{"location":"references/#jaxqualin.fit.QNMFitVaryingStartingTime.initial_guesses","title":"<code>initial_guesses(jcf=None)</code>","text":"<p>Generate initial guesses for the first <code>t0</code> fit.</p> <p>Parameters:</p> Name Type Description Default <code>jcf</code> <code>Optional[CurveFit]</code> <p><code>jaxfit</code> curve fit object.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>best_guess_index</code> <code>int</code> <p>index of the best initial guess.</p> <code>qnm_fit_list</code> <code>List[QNMFit]</code> <p>list of <code>QNMFit</code> objects for the initial guesses.</p> <code>guess_list</code> <code>List[ndarray]</code> <p>list of initial guess parameters used.</p>"},{"location":"references/#jaxqualin.fit.QNMFitVaryingStartingTime.make_nan_result","title":"<code>make_nan_result()</code>","text":"<p>Generate a <code>QNMFitVaryingStartingTimeResult</code> object with <code>nan</code> values.</p>"},{"location":"references/#jaxqualin.plot","title":"<code>plot</code>","text":""},{"location":"references/#jaxqualin.plot.plot_amplitudes","title":"<code>plot_amplitudes(results_full, fixed_modes=None, ax=None, alpha=1.0, ls='-', use_label=True, legend=True, color_dict={}, lw=2.0, bold_dict={}, lw_bold=4.0, alpha_bold=1.0, t_flat_start_dict={}, flat_start_s=20, flat_start_marker='o', plot_mirror_pred=False, iota=None, psi=0.0, af=None, A_fac=1.0)</code>","text":"<p>Plot the amplitudes of the QNM modes as a function of starting time of the fit.</p> <p>Parameters:</p> Name Type Description Default <code>results_full</code> <code>Union[QNMFitVaryingStartingTimeResult, QNMFitVaryingStartingTimeResultVarMa]</code> <p>The results object of the fit.</p> required <code>fixed_modes</code> <code>Optional[Union[QNMFitVaryingStartingTimeResult, QNMFitVaryingStartingTimeResultVarMa]]</code> <p>The list of fixed modes to plot.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>The matplotlib axes to plot on. If None, a new figure and axes will be created.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>The alpha value of the lines.</p> <code>1.0</code> <code>ls</code> <code>str</code> <p>The line style of the lines.</p> <code>'-'</code> <code>use_label</code> <code>bool</code> <p>Whether to use the mode name as the legend label.</p> <code>True</code> <code>legend</code> <code>bool</code> <p>Whether to include the legend.</p> <code>True</code> <code>color_dict</code> <code>Dict[str, str]</code> <p>A dictionary of the colors of the mode names.</p> <code>{}</code> <code>lw</code> <code>float</code> <p>The line width of the lines.</p> <code>2.0</code> <code>bold_dict</code> <code>Dict[str, Tuple[int, int]]</code> <p>A dictionary of mode names to tuples of indices indicating the starting and ending index of the region where the amplitude is flat. The line between the indices will be plotted with a larger line width.</p> <code>{}</code> <code>lw_bold</code> <code>float</code> <p>The line width of the lines between the corresponding indices in <code>bold_dict</code>.</p> <code>4.0</code> <code>alpha_bold</code> <code>float</code> <p>The alpha value of the lines corresponding to the indices in <code>bold_dict</code>.</p> <code>1.0</code> <code>t_flat_start_dict</code> <code>Dict[str, float]</code> <p>A dictionary of mode names to the optimal starting times. A scatter point will be plotted at the starting time of the fit for the corresponding mode.</p> <code>{}</code> <code>flat_start_s</code> <code>float</code> <p>The size of the scatter points corresponding to the indices in <code>t_flat_start_dict</code>.</p> <code>20</code> <code>flat_start_marker</code> <code>str</code> <p>The marker of the scatter points corresponding to the indices in <code>t_flat_start_dict</code>.</p> <code>'o'</code> <code>plot_mirror_pred</code> <code>bool</code> <p>Whether to plot the predicted amplitude of the mirror modes.</p> <code>False</code> <code>iota</code> <code>Optional[float]</code> <p>The inclination angle of the source.</p> <code>None</code> <code>psi</code> <code>float</code> <p>polarization angle of the source.</p> <code>0.0</code> <code>af</code> <code>Optional[float]</code> <p>The remnant spin of the black hole.</p> <code>None</code> <code>A_fac</code> <code>float</code> <p>The factor by which to multiply the amplitudes.</p> <code>1.0</code>"},{"location":"references/#jaxqualin.plot.plot_mode_searcher_results","title":"<code>plot_mode_searcher_results(mode_searcher_vary_N, axs=None)</code>","text":"<p>Plot the results of the best mode searcher in a <code>ModeSearchAllFreeVaryingN</code> object, including the frequency evolution of the free fit, and the amplitudes and phases of the final modes.</p> <p>Parameters:</p> Name Type Description Default <code>mode_searcher_vary_N</code> <code>ModeSearchAllFreeVaryingN</code> <p>The <code>ModeSearchAllFreeVaryingN</code> object to plot the results of.</p> required <code>axs</code> <code>Optional[Axes]</code> <p>The axes to plot on. If None, a new figure and axes is created.</p> <code>None</code>"},{"location":"references/#jaxqualin.plot.plot_omega_free","title":"<code>plot_omega_free(results_full, ax=None, plot_indxs=[], t0_min=None, t0_max=None, indicate_start=False, color=None, line_alpha=0.3, scatter_alpha=0.5, scatter_size=1.0, color_indicate=False, color_indicate_list=[])</code>","text":"<p>Plot the complex QNM frequencies as a function of starting time of the fit.</p> <p>Parameters:</p> Name Type Description Default <code>results_full</code> <code>Union[QNMFitVaryingStartingTimeResult, QNMFitVaryingStartingTimeResultVarMa]</code> <p>The results object of the fit.</p> required <code>ax</code> <code>Axes</code> <p>The matplotlib axes to plot on. If None, a new figure and axes will be created.</p> <code>None</code> <code>plot_indxs</code> <code>List[int]</code> <p>The indices of the modes to plot. If empty, all modes will be plotted.</p> <code>[]</code> <code>t0_min</code> <code>Optional[float]</code> <p>The minimum starting time to plot.</p> <code>None</code> <code>t0_max</code> <code>Optional[float]</code> <p>The maximum starting time to plot.</p> <code>None</code> <code>indicate_start</code> <code>bool</code> <p>Whether to indicate the starting point of the fit with a marker.</p> <code>False</code> <code>color</code> <code>Optional[str]</code> <p>The color of the scatter points and line.</p> <code>None</code> <code>line_alpha</code> <code>float</code> <p>The alpha value of the line.</p> <code>0.3</code> <code>scatter_alpha</code> <code>float</code> <p>The alpha value of the scatter points.</p> <code>0.5</code> <code>scatter_size</code> <code>float</code> <p>The size of the scatter points.</p> <code>1.0</code> <code>color_indicate</code> <code>bool</code> <p>Whether to color the scatter points and line according to <code>color_indicate_list</code>.</p> <code>False</code> <code>color_indicate_list</code> <code>List[int]</code> <p>Which default color to use for each mode, if <code>color_indicate</code> is <code>True</code>.</p> <code>[]</code>"},{"location":"references/#jaxqualin.plot.plot_phases","title":"<code>plot_phases(results_full, fixed_modes=None, ax=None, alpha=1.0, ls='-', use_label=True, shift_phase=True, legend=True, color_dict={}, lw=2.0, bold_dict={}, lw_bold=4.0, alpha_bold=1.0, t_flat_start_dict={}, flat_start_s=20, flat_start_marker='o', plot_mirror_pred=False, iota=None, psi=0.0, af=None)</code>","text":"<p>Plot the phases of the QNM modes as a function of starting time of the fit.</p> <p>Parameters:</p> Name Type Description Default <code>results_full</code> <code>Union[QNMFitVaryingStartingTimeResult, QNMFitVaryingStartingTimeResultVarMa]</code> <p>The results object of the fit.</p> required <code>fixed_modes</code> <code>Optional[Union[QNMFitVaryingStartingTimeResult, QNMFitVaryingStartingTimeResultVarMa]]</code> <p>The list of fixed modes to plot.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>The matplotlib axes to plot on. If None, a new figure and axes will be created.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>The alpha value of the lines.</p> <code>1.0</code> <code>ls</code> <code>str</code> <p>The line style of the lines.</p> <code>'-'</code> <code>use_label</code> <code>bool</code> <p>Whether to use the mode name as the legend label.</p> <code>True</code> <code>shift_phase</code> <code>bool</code> <p>Whether to shift the phase by <code>pi</code> if the amplitude is negative.</p> <code>True</code> <code>legend</code> <code>bool</code> <p>Whether to include the legend.</p> <code>True</code> <code>color_dict</code> <code>Dict[str, str]</code> <p>A dictionary of the colors of the mode names.</p> <code>{}</code> <code>lw</code> <code>float</code> <p>The line width of the lines.</p> <code>2.0</code> <code>bold_dict</code> <code>Dict[str, Tuple[int, int]]</code> <p>A dictionary of mode names to tuples of indices indicating the starting and ending index of the region where the amplitude is flat. The line between the indices will be plotted with a larger line width.</p> <code>{}</code> <code>lw_bold</code> <code>float</code> <p>The line width of the lines corresponding to the indices in <code>bold_dict</code>.</p> <code>4.0</code> <code>alpha_bold</code> <code>float</code> <p>The alpha value of the lines corresponding to the indices in <code>bold_dict</code>.</p> <code>1.0</code> <code>t_flat_start_dict</code> <code>Dict[str, float]</code> <p>A dictionary of mode names to the optimal starting times. A scatter point will be plotted at the starting time of the fit for the corresponding mode.</p> <code>{}</code> <code>flat_start_s</code> <code>int</code> <p>The size of the scatter points corresponding to the indices in <code>t_flat_start_dict</code>.</p> <code>20</code> <code>flat_start_marker</code> <code>str</code> <p>The marker of the scatter points corresponding to the indices in <code>t_flat_start_dict</code>.</p> <code>'o'</code> <code>plot_mirror_pred</code> <code>bool</code> <p>Whether to plot the predicted phase of the mirror modes.</p> <code>False</code> <code>iota</code> <code>Optional[float]</code> <p>The inclination angle of the source.</p> <code>None</code> <code>psi</code> <code>float</code> <p>polarization angle of the source.</p> <code>0.0</code> <code>af</code> <code>Optional[float]</code> <p>The remnant spin of the black hole.</p> <code>None</code>"},{"location":"references/#jaxqualin.plot.plot_predicted_qnms","title":"<code>plot_predicted_qnms(ax, predicted_qnm_list, alpha_r=0.05, alpha_i=0.05, ellipse_edgecolor='gray', ellipse_facecolor='lightgray', ellipse_alpha=0.5, fix_indx=[], label_offset=(0, 0.0), change_lim=True, facecolor='none', edgecolor='gray', cut_at_0=False, pred_alpha=1.0, present_modes=[], edgecolor_present='k', expand_points=(1.1, 1.7), xminmin=-2, xmaxmax=2, yminmin=0.05, ymaxmax=-0.7, positive_y_alpha=0.5)</code>","text":"<p>Plot the expected QNM frequencies on the complex plane.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib axes to plot on.  </p> required <code>predicted_qnm_list</code> <code>List[mode]</code> <p>The list of expected QNM modes to plot in the complex plane.  </p> required <code>alpha_r</code> <code>float</code> <p>The half width of the ellipse in the real direction.</p> <code>0.05</code> <code>alpha_i</code> <code>float</code> <p>The half width of the ellipse in the imaginary direction.</p> <code>0.05</code> <code>ellipse_edgecolor</code> <code>str</code> <p>The color of the ellipse edge.</p> <code>'gray'</code> <code>ellipse_facecolor</code> <code>str</code> <p>The color of the ellipse face.</p> <code>'lightgray'</code> <code>ellipse_alpha</code> <code>float</code> <p>The alpha value of the ellipse.</p> <code>0.5</code> <code>fix_indx</code> <code>List[int]</code> <p>The indices of the modes included in the fit with fixed frequencies. These modes will appear as solid black circles.</p> <code>[]</code> <code>label_offset</code> <code>Tuple[float, float]</code> <p>The offset of the mode labels from the mode position.</p> <code>(0, 0.0)</code> <code>change_lim</code> <code>bool</code> <p>Whether to change the axes limits of the <code>ax</code> passed.</p> <code>True</code> <code>facecolor</code> <code>str</code> <p>The face color of the scatter points.</p> <code>'none'</code> <code>edgecolor</code> <code>str</code> <p>The edge color of the scatter points.</p> <code>'gray'</code> <code>cut_at_0</code> <code>bool</code> <p>Whether to cut the axes at <code>omegai = 0</code>.</p> <code>False</code> <code>pred_alpha</code> <code>float</code> <p>The alpha value of the scatter points and labels.</p> <code>1.0</code> <code>present_modes</code> <code>List[str]</code> <p>The list of modes that are deemed present in the waveform.</p> <code>[]</code> <code>edgecolor_present</code> <code>str</code> <p>The edge color of the scatter points and labels of the modes that are deemed present in the waveform.</p> <code>'k'</code> <code>expand_points</code> <code>Tuple[float, float]</code> <p>The expansion factor passed to <code>adjustText.adjust_text</code>.</p> <code>(1.1, 1.7)</code> <code>xminmin</code> <code>float</code> <p>The minimum value of the x-axis after adjusting.</p> <code>-2</code> <code>xmaxmax</code> <code>float</code> <p>The maximum value of the x-axis after adjusting.</p> <code>2</code> <code>yminmin</code> <code>float</code> <p>The minimum value of the y-axis after adjusting.</p> <code>0.05</code> <code>ymaxmax</code> <code>float</code> <p>The maximum value of the y-axis after adjusting.</p> <code>-0.7</code>"},{"location":"references/#jaxqualin.postprocess","title":"<code>postprocess</code>","text":""},{"location":"references/#jaxqualin.qnmode","title":"<code>qnmode</code>","text":""},{"location":"references/#jaxqualin.qnmode.mode","title":"<code>mode</code>","text":"<p>             Bases: <code>mode_free</code></p> <p>A class representing a frequency-fixed mode of a black hole.</p> <p>Attributes:</p> Name Type Description <code>M</code> <code>float</code> <p>The mass of the black hole.</p> <code>a</code> <code>float</code> <p>The spin parameter of the black hole.</p> <code>retro_def_orbit</code> <code>bool</code> <p>Whether define retrograde modes with respect to the orbital frame (<code>True</code>) or remnant black hole frame (<code>False</code>). See the methods paper for details.</p>"},{"location":"references/#jaxqualin.qnmode.mode_free","title":"<code>mode_free</code>","text":"<p>A class representing a mode of a black hole.</p> <p>Attributes:</p> Name Type Description <code>lmnx</code> <code>Union[List[List[int]], str]</code> <p>A list of lists of integers representing the mode numbers, or a string equal to <code>constant</code>. Each list of integers represents a constituent linear mode, and the list of lists represents a nonlinear mode if <code>len(lmnx) &gt; 1</code>. For example, <code>[[2, 2, 0], [3, 3, 0]]</code> represents the <code>2,2,0x3,3,0</code> quadratic mode.</p> <code>spinseq_list</code> <code>List[KerrSpinSeq]</code> <p>A list of <code>qnm.spinsequence.KerrSpinSeq</code> objects of the <code>qnm</code> package that maps the spin parameter <code>a</code> of the black hole into the QNM frequencies.</p> <code>spinseq_list_neg_a</code> <code>List[KerrSpinSeq]</code> <p>Same as <code>spinseq_list</code> but for the retrograde branch of the QNM solution.</p> <code>omegar</code> <code>float</code> <p>The real part of the QNM , if fixed. <code>jaxlib.xla_extension.ArrayImpl</code> of a single <code>jnp.float64</code>.</p> <code>omegai</code> <code>float</code> <p>The imaginary part of the QNM frequency, if fixed. <code>jaxlib.xla_extension.ArrayImpl</code> of a single <code>jnp.float64</code>.</p> <code>omega</code> <code>complex</code> <p>The complex QNM frequency, if fixed. <code>jaxlib.xla_extension.ArrayImpl</code> of a single <code>jnp.complex128</code>.</p> <code>M</code> <code>float</code> <p>The mass of the black hole, if fixed.</p> <code>a</code> <code>float</code> <p>The spin parameter of the black hole, if fixed.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes a mode_free object. </p> <code>fix_mode</code> <p>Fixes the complex frequency of the mode.</p>"},{"location":"references/#jaxqualin.qnmode.mode_free.__init__","title":"<code>__init__(lmnx, s=-2)</code>","text":"<p>Initializes a mode_free object.</p> <p>Parameters:</p> Name Type Description Default <code>lmnx</code> <code>Union[List[List[int]], str]</code> <p>A list of lists of integers representing the mode numbers, or a string equal to <code>constant</code>. Each list of integers represents a constituent linear mode, and the list of lists represents a nonlinear mode if <code>len(lmnx) &gt; 1</code>. For example, <code>[[2, 2, 0], [3, 3, 0]]</code> represents the <code>2,2,0x3,3,0</code> quadratic mode.</p> required <code>s</code> <code>int</code> <p>The spin weight of the mode. Defaults to -2.</p> <code>-2</code>"},{"location":"references/#jaxqualin.qnmode.mode_free.fix_mode","title":"<code>fix_mode(M, a, retro_def_orbit=True)</code>","text":"<p>Fixes the complex frequency of the mode.</p> <p>Parameters:</p> Name Type Description Default <code>M</code> <code>float</code> <p>The mass of the black hole.</p> required <code>a</code> <code>float</code> <p>The spin parameter of the black hole.</p> required <code>retro_def_orbit</code> <code>bool</code> <p>Whether to define retrograde modes with respect to the orbital frame (<code>True</code>) or remnant black hole frame (<code>False</code>). See the methods paper for details. Defaults to True.</p> <code>True</code>"},{"location":"references/#jaxqualin.qnmode.mode_free.is_overtone","title":"<code>is_overtone()</code>","text":"<p>Determines whether the mode is an overtone.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the mode is an overtone.</p>"},{"location":"references/#jaxqualin.qnmode.mode_free.string","title":"<code>string()</code>","text":"<p>Returns a string representation of the mode numbers.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the mode numbers.</p>"},{"location":"references/#jaxqualin.qnmode.mode_free.sum_lm","title":"<code>sum_lm()</code>","text":"<p>Returns the sum of the mode quantum numbers of constituent linear modes.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>The sum of the mode quantum numbers of constituent linear modes.</p>"},{"location":"references/#jaxqualin.qnmode.mode_free.tex_string","title":"<code>tex_string()</code>","text":"<p>Returns a TeX string representation of the mode numbers.</p> <p>Returns:</p> Type Description <code>str</code> <p>A TeX string representation of the mode numbers.</p>"},{"location":"references/#jaxqualin.selection","title":"<code>selection</code>","text":""},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingN","title":"<code>ModeSearchAllFreeVaryingN</code>","text":"<p>A class that performs a mode search for a given waveform, varying the number of free modes used in the fit.</p> <p>Attributes:</p> Name Type Description <code>h</code> <code>waveform</code> <p>The waveform to be fit.</p> <code>l</code> <code>int</code> <p>The harmonic number l of the waveform.</p> <code>m</code> <code>int</code> <p>The harmonic number m of the waveform.</p> <code>M</code> <code>float</code> <p>The mass of the black hole.</p> <code>a</code> <code>float</code> <p>The dimensionless spin of the black hole.</p> <code>relevant_lm_list</code> <code>List[Tuple[int, int]]</code> <p>A list of tuples of the form (l, m) that specifies which recoil modes are relevant for the waveform.</p> <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting.</p> <code>N_list</code> <code>List[int]</code> <p>A list of integers that specifies the number of free modes to be used in each mode searcher in <code>mode_searchers</code>.</p> <code>kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments.</p> <code>flatness_checker_kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments for the <code>IterativeFlatnessChecker</code> class.</p> <code>mode_searcher_kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments for the <code>ModeSearchAllFreeLM</code> class.</p> <code>mode_searchers</code> <code>List[ModeSearchAllFreeLM]</code> <p>A list of <code>ModeSearchAllFreeLM</code> objects for mode searching with different number of free modes.</p> <code>found_modes_final</code> <code>List[mode]</code> <p>A list of <code>mode</code> objects that contains the final list of modes found by the best mode searcher.</p> <code>run_string_prefix</code> <code>str</code> <p>A string that is used as a prefix for the run name for dumping the <code>pickle</code> file.</p> <code>load_pickle</code> <code>bool</code> <p>A boolean that specifies whether to load the <code>pickle</code> file.</p> <code>CCE</code> <code>bool</code> <p>A boolean that specifies whether the waveform is a CCE waveform. This is not implemented yet.</p> <code>fixed_fitters</code> <code>List[QNMFitVaryingStartingTime]</code> <p>A list of <code>QNMFitVaryingStartingTime</code> objects that contains the final list of fitters used for the flatness checkers in each mode searcher.</p> <code>flatness_checkers</code> <code>List[IterativeFlatnessChecker]</code> <p>A list of <code>IterativeFlatnessChecker</code> objects that contains the list of flatness checkers used for the mode searchers.</p> <code>best_run_indx</code> <code>int</code> <p>An integer that specifies the index of the mode searcher that found the most number of modes.</p> <p>Methods:</p> Name Description <code>init_searchers</code> <p>Initializes the mode searchers. </p> <code>do_mode_searches</code> <p>Performs the mode searches.</p>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingN.__init__","title":"<code>__init__(h, M, a, relevant_lm_list=[], t0_arr=np.linspace(0, 50, num=501), flatness_checker_kwargs={}, mode_searcher_kwargs={}, **kwargs_in)</code>","text":"<p>Initialize the <code>ModeSearchAllFreeVaryingN</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>waveform</code> <p>The waveform to be fit.</p> required <code>M</code> <code>float</code> <p>The mass of the black hole.</p> required <code>a</code> <code>float</code> <p>The dimensionless spin of the black hole.</p> required <code>relevant_lm_list</code> <code>List[Tuple[int, int]]</code> <p>A list of tuples of the form (l, m) that specifies which recoil modes are relevant for the waveform.</p> <code>[]</code> <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting.</p> <code>linspace(0, 50, num=501)</code> <code>flatness_checker_kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments for the <code>IterativeFlatnessChecker</code> class.</p> <code>{}</code> <code>mode_searcher_kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments for the <code>ModeSearchAllFreeLM</code> class.</p> <code>{}</code> <code>**kwargs_in</code> <code>Any</code> <p>keyword arguments.</p> <code>{}</code>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingN.do_mode_searches","title":"<code>do_mode_searches()</code>","text":"<p>Performs the mode searches.</p>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingN.init_searchers","title":"<code>init_searchers()</code>","text":"<p>Initializes the mode searchers.</p>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS","title":"<code>ModeSearchAllFreeVaryingNSXS</code>","text":"<p>A class that performs a mode search for a given SXS waveform, varying the number of free modes used in the fit.</p> <p>Attributes:</p> Name Type Description <code>SXSnum</code> <code>str</code> <p>The SXS number of the waveform. </p> <code>l</code> <code>int</code> <p>The harmonic number l of the</p> <code>waveform.</code> <code>m</code> <p>The harmonic number m of the waveform. </p> <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting. </p> <code>N_list</code> <code>List[int]</code> <p>A list of integers that specifies the number of free modes to be used in each mode searcher in <code>mode_searchers</code>.</p> <code>postfix_string</code> <code>str</code> <p>A string that is appended to the run name for dumping the <code>pickle</code> file.</p> <code>CCE</code> <code>bool</code> <p>A boolean that specifies whether the waveform is a CCE waveform. This is not implemented yet.</p> <code>kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments. </p> <code>retro_def_orbit</code> <code>bool</code> <p>Whether to define retrograde modes with respect to the orbital frame (<code>True</code>) or remnant black hole frame (<code>False</code>). See the methods paper for details. Defaults to True.</p> <code>relevant_lm_list_override</code> <code>bool</code> <p>A boolean that specifies whether to override the <code>relevant_lm_list</code> attribute of the <code>ModeSearchAllFreeVaryingN</code> class.</p> <code>relevant_lm_list</code> <code>List[Tuple[int, int]]</code> <p>A list of tuples of the form (l, m) that specifies which recoil modes are relevant for the waveform. Used if <code>relevant_lm_list_override</code> is <code>True</code>.</p> <code>h</code> <code>waveform</code> <p>The waveform to be fit. </p> <code>M</code> <code>float</code> <p>The mass of the black hole. </p> <code>a</code> <code>float</code> <p>The dimensionless spin of the black hole. </p> <code>Lev</code> <code>int</code> <p>The resolution level of the SXS simulation. </p> <code>N_list_string</code> <code>str</code> <p>A string that is used as a suffix for the run name for dumping the <code>pickle</code> file.</p> <code>run_string_fitter</code> <code>str</code> <p>A string that is used as a prefix for the run name for dumping the <code>pickle</code> file for the fitters.</p> <code>run_string</code> <code>str</code> <p>A string that is used as a prefix for the run name for dumping the <code>pickle</code> file for the mode searcher.</p> <code>run_string_full</code> <code>str</code> <p>A string that is used as a prefix for the run name for dumping the <code>pickle</code> file for the mode searcher, including the <code>postfix_string</code>.</p> <code>file_path</code> <code>str</code> <p>The path to the <code>pickle</code> file. </p> <code>load_pickle</code> <code>bool</code> <p>A boolean that specifies whether to load the <code>pickle</code> file for the fitters.</p> <code>mode_searcher_load_pickle</code> <code>bool</code> <p>A boolean that specifies whether to load the <code>pickle</code> file for the mode searcher.</p> <code>set_seed</code> <code>int</code> <p>An integer that specifies the seed for the random number generator.</p> <code>save_mode_searcher</code> <code>bool</code> <p>A boolean that specifies whether to save the mode searcher to a <code>pickle</code> file.</p> <code>mode_searcher_vary_N</code> <code>ModeSearchAllFreeVaryingN</code> <p>A <code>ModeSearchAllFreeVaryingN</code> object that performs the mode search.</p> <code>found_modes_final</code> <code>List[mode]</code> <p>A list of <code>mode</code> objects that contains the final list of modes found by the best mode searcher.</p> <p>Methods:</p> Name Description <code>mode_search_varying_N_sxs</code> <p>Performs the mode searches.</p> <code>do_mode_search_varying_N</code> <p>Performs the mode searches and dumps the class instance to a <code>pickle</code> file. </p> <code>get_waveform</code> <p>Loads the waveform from the SXS catalog. </p> <code>pickle_save</code> <p>Dumps the class instance to a <code>pickle</code> file.</p> <code>pickle_load</code> <p>Check whether a <code>pickle</code> file exists and can be loaded.</p>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.__init__","title":"<code>__init__(SXSnum, l, m, t0_arr=np.linspace(0, 50, num=501), **kwargs_in)</code>","text":"<p>Initialize the <code>ModeSearchAllFreeVaryingNSXS</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>SXSnum</code> <code>str</code> <p>The SXS number of the waveform.</p> required <code>l</code> <code>int</code> <p>The harmonic number l of the waveform.</p> required <code>m</code> <code>int</code> <p>The harmonic number m of the waveform.</p> required <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting.</p> <code>linspace(0, 50, num=501)</code> <code>**kwargs_in</code> <code>Any</code> <p>keyword arguments.</p> <code>{}</code>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.do_mode_search_varying_N","title":"<code>do_mode_search_varying_N()</code>","text":"<p>Performs the mode searches and dumps the class instance to a <code>pickle</code> file.</p>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.get_waveform","title":"<code>get_waveform()</code>","text":"<p>Loads the waveform from the SXS catalog.</p>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.mode_search_varying_N_sxs","title":"<code>mode_search_varying_N_sxs()</code>","text":"<p>Performs the mode searches.</p>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.pickle_exists","title":"<code>pickle_exists()</code>","text":"<p>Check whether a <code>pickle</code> file exists and can be loaded.</p>"},{"location":"references/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.pickle_save","title":"<code>pickle_save()</code>","text":"<p>Dump the class instance to a <code>pickle</code> file.</p>"},{"location":"references/#jaxqualin.waveforms","title":"<code>waveforms</code>","text":""},{"location":"references/#jaxqualin.waveforms.waveform","title":"<code>waveform</code>","text":"<p>A class representing a waveform containing a ringdown phase to be fitted.</p> <p>Attributes:</p> Name Type Description <code>fulltime</code> <code>ndarray</code> <p>The full time array of the waveform. </p> <code>fullh</code> <code>ndarray</code> <p>The full complex waveform. </p> <code>peaktime</code> <code>float</code> <p>The time of peak strain <code>jnp.abs(h)</code> of the waveform. </p> <code>peakindx</code> <code>int</code> <p>The array index of the time of peak strain of the waveform.</p> <code>t_peak</code> <code>int</code> <p>The time of peak strain of the waveform. This can be defined by the user and overrides <code>peaktime</code>.</p> <code>time</code> <code>ndarray</code> <p>The time array of the waveform after the peak, starting at <code>t_peak</code> and time shifted such that <code>t_peak = 0</code>.</p> <code>hr</code> <code>ndarray</code> <p>The real part of the waveform after the peak.</p> <code>hi</code> <code>ndarray</code> <p>The imaginary part of the waveform after the peak. </p> <code>h</code> <code>ndarray</code> <p>The complex waveform after the peak.</p> <code>l</code> <code>int</code> <p>The spherical harmonic mode number l of the waveform. </p> <code>m</code> <code>int</code> <p>The spherical harmonic mode number m of the waveform.</p> <p>Methods:</p> Name Description <code>update_peaktime</code> <p>Sets <code>t_peak</code> to override the peak time. </p> <code>argabsmax</code> <p>Returns the array index of the time of peak strain of the  waveform.</p> <code>postmerger</code> <p>Returns the time, real part, and imaginary part of the waveform after the peak. </p> <code>set_lm</code> <p>Sets the spherical harmonic mode numbers l and m of the  waveform.</p>"},{"location":"references/#jaxqualin.waveforms.waveform.__init__","title":"<code>__init__(fulltime, fullh, t_peak=None, t_start=0.0, t_end=np.inf, l=None, m=None, remove_num=500)</code>","text":"<p>Initialize a waveform.</p> <p>Parameters:</p> Name Type Description Default <code>fulltime</code> <code>ndarray</code> <p>The full time array of the waveform.</p> required <code>fullh</code> <code>ndarray</code> <p>The full complex waveform.</p> required <code>t_peak</code> <code>Optional[float]</code> <p>The time of peak strain of the waveform. This can be defined by the user and overrides <code>peaktime</code>.</p> <code>None</code> <code>t_start</code> <code>float</code> <p>The time after the peak to start the waveform.</p> <code>0.0</code> <code>t_end</code> <code>float</code> <p>The time after the peak to end the waveform.</p> <code>inf</code> <code>l</code> <code>int</code> <p>The spherical harmonic mode number l of the waveform.</p> <code>None</code> <code>m</code> <code>int</code> <p>The spherical harmonic mode number m of the waveform.</p> <code>None</code> <code>remove_num</code> <code>int</code> <p>The number of points to remove from the beginning of the waveform to avoid numerical artifacts.</p> <code>500</code>"},{"location":"references/#jaxqualin.waveforms.waveform.argabsmax","title":"<code>argabsmax(remove_num=500)</code>","text":"<p>Returns the array index of the time of peak strain of the waveform.</p> <p>Parameters:</p> Name Type Description Default <code>remove_num</code> <code>int</code> <p>The number of points to remove from the beginning of the waveform to avoid numerical artifacts.</p> <code>500</code> <p>Returns:</p> Type Description <code>int</code> <p>The array index of the time of peak strain of the waveform.</p>"},{"location":"references/#jaxqualin.waveforms.waveform.postmerger","title":"<code>postmerger(t_start, t_end=np.inf)</code>","text":"<p>Returns the time, real part, and imaginary part of the waveform after the peak.</p> <p>Parameters:</p> Name Type Description Default <code>t_start</code> <code>float</code> <p>The time after the peak to start the waveform. t_end: The time after the peak to end the waveform.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The time, real part, and imaginary part of the waveform after the</p> <code>ndarray</code> <p>peak.</p>"},{"location":"references/#jaxqualin.waveforms.waveform.set_lm","title":"<code>set_lm(l, m)</code>","text":"<p>Sets the spherical harmonic mode numbers l and m of the waveform.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>int</code> <p>The spherical harmonic mode number l of the waveform.</p> required <code>m</code> <code>int</code> <p>The spherical harmonic mode number m of the waveform.</p> required"},{"location":"references/#jaxqualin.waveforms.waveform.update_peaktime","title":"<code>update_peaktime(t_peak)</code>","text":"<p>Override the peak time of the waveform.</p> <p>Parameters:</p> Name Type Description Default <code>t_peak</code> <code>float</code> <p>The user-defined peak time of the waveform.</p> required"},{"location":"references/#jaxqualin.waveforms.get_SXS_waveform_summed","title":"<code>get_SXS_waveform_summed(SXSnum, iota, psi, l_max=4, res=0, N_ext=2)</code>","text":"<p>Obtain the waveform of a SXS simulation summed over all modes up to l_max.</p> <p>Parameters:</p> Name Type Description Default <code>SXSnum</code> <code>str</code> <p>The SXS simulation number.</p> required <code>iota</code> <code>float</code> <p>The inclination angle of the binary.</p> required <code>psi</code> <code>float</code> <p>The phase to use.</p> required <code>l_max</code> <code>int</code> <p>The maximum l mode to include in the waveform.</p> <code>4</code> <code>res</code> <code>int</code> <p>The level of the simulation, relative to the highest resolution level  (<code>res = 0</code> means highest resolution). Must be zero or negative.</p> <code>0</code> <code>N_ext</code> <code>int</code> <p>The extrapolation order of the simulation.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>h</code> <code>waveform</code> <p>The waveform.</p> <code>Mf</code> <code>float</code> <p>The final mass of the binary.</p> <code>af</code> <code>float</code> <p>The final spin of the binary.</p>"},{"location":"api/data/","title":"API for the <code>jaxqualin.data</code> module","text":""},{"location":"api/data/#jaxqualin.data.download_file","title":"<code>download_file(filepath, url, overwrite='update')</code>","text":"<p>Downloads a file from a url to a filepath</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath to save the downloaded file to</p> required <code>url</code> <code>str</code> <p>The url to download the file from</p> required <code>overwrite</code> <code>str</code> <p>Whether to overwrite the file if it already exists. Can be one of 'force', 'update', or 'never'.</p> <code>'update'</code>"},{"location":"api/data/#jaxqualin.data.last_modified_time","title":"<code>last_modified_time(url)</code>","text":"<p>Returns the last modified time of a url</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to check the last modified time of</p> required <p>Returns:</p> Type Description <code>struct_time</code> <p>The last modified time of the url as a time.struct_time object</p>"},{"location":"api/data/#jaxqualin.data.make_hyper_fit_functions","title":"<code>make_hyper_fit_functions(filepath=_default_hyperfit_data_path, PN=True)</code>","text":"<p>Make a dictionary of hyperfit functions from a hyperfit data file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath of the hyperfit data file.</p> <code>_default_hyperfit_data_path</code> <code>PN</code> <code>bool</code> <p>Whether to use Post Newtonian variables (<code>eta</code>, <code>chi_p</code>, <code>chi_m</code>) or the natural parameterization of the BBH simulations (<code>q</code>, <code>chi_1</code>, <code>chi_2</code>).</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Callable[[float, float, float], float]]]</code> <p>A dictionary of hyperfit functions. The keys are the mode names, and the values are dictionaries with keys <code>A</code> and <code>phi</code> for the amplitude and phase hyperfit functions, respectively.</p>"},{"location":"api/data/#jaxqualin.data.make_interpolators","title":"<code>make_interpolators(filepath=_default_interpolate_data_path, PN=True)</code>","text":"<p>Make a dictionary of interpolators from a data file containing the extracted amplitude and phases of different modes from BBH simulations.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath of the data file.</p> <code>_default_interpolate_data_path</code> <code>PN</code> <code>bool</code> <p>Whether to use Post Newtonian variables (<code>eta</code>, <code>chi_p</code>, <code>chi_m</code>) or the natural parameterization of the BBH simulations (<code>q</code>, <code>chi_1</code>, <code>chi_2</code>).</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, LinearNDInterpolator]]</code> <p>A dictionary of interpolators. The keys are the mode names, and the values are dictionaries with keys <code>A</code>, <code>dA</code>, <code>phi</code>, and <code>dphi</code> for the amplitude, amplitude fluctuation, phase, and phase fluctuation interpolators, respectively.</p>"},{"location":"api/fit/","title":"API for the <code>jaxqualin.fit</code> module","text":""},{"location":"api/fit/#jaxqualin.fit.QNMFitVaryingStartingTime","title":"<code>QNMFitVaryingStartingTime</code>","text":"<p>A class for fitting the postmerger waveform with a varying starting time.</p> <p>Attributes:</p> Name Type Description <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting. </p> <code>h</code> <code>waveform</code> <p>waveform object to be fitted. </p> <code>var_M_a</code> <code>bool</code> <p>fit for the mass and spin of the black hole. </p> <code>Warning</code> <code>bool</code> <p>Not tested yet.</p> <code>Schwarzschild</code> <code>bool</code> <p>whether to fit for Schwarzschild black hole, i.e. real waveform.</p> <code>N_free</code> <code>int</code> <p>number of frequency-free QNMs to include in the model. These modes are completely free, i.e. their mode numbers are not fixed like those in <code>qnm_free_list</code>.</p> <code>qnm_fixed_list</code> <code>List[mode]</code> <p>list of fixed-frequency QNMs included in the model.</p> <code>qnm_free_list</code> <code>List[mode_free]</code> <p>list of free-frequency QNMs of fixed mode numbers to include in the model, only used for fitting <code>M</code> and <code>a</code> when <code>var_M_a = True</code>.</p> <code>N_free</code> <code>int</code> <p>number of free QNMs. </p> <code>run_string_prefix</code> <code>str</code> <p>prefix of the run name for dumping the <code>pickle</code> file.</p> <code>nonconvergence_cut</code> <code>bool</code> <p>whether to cut the nonconverged fits.</p> <code>nonconvergence_indx</code> <code>List[int]</code> <p>indices of the nonconverged fits. </p> <code>initial_num</code> <code>int</code> <p>number of initial guesses to use for the first starting time for frequency-free fits.</p> <code>include_mirror</code> <code>bool</code> <p>whether to include the mirror modes, for fitting waveforms with both waveform polarizations.</p> <code>mirror_ratio_list</code> <code>List[float]</code> <p>list of ratios between prograde and mirror mode amplitudes.</p> <code>iota</code> <code>float</code> <p>inclination angle of the source. </p> <code>psi</code> <code>float</code> <p>polarization angle of the source. </p> <code>save_results</code> <code>bool</code> <p>whether to save the results. </p> <code>params0</code> <code>ndarray</code> <p>initial guess for the fit parameters, at least for the earliest <code>t0</code> fit.</p> <code>max_nfev</code> <code>int</code> <p>maximum number of function evaluations for the fit.</p> <code>sequential_guess</code> <code>bool</code> <p>whether to use the previous fit as the initial guess for the next fit.</p> <code>load_pickle</code> <code>bool</code> <p>whether to load the <code>pickle</code> file if it exists.</p> <code>fit_save_prefix</code> <code>str</code> <p>prefix of the path to save the <code>pickle</code> file. </p> <code>A_bound</code> <code>float</code> <p>maximum value of the amplitude. </p> <code>jcf</code> <code>CurveFit</code> <p><code>jaxfit</code> curve fit object.</p> <code>fit_kwargs</code> <code>Dict[str, Any]</code> <p>keyword arguments for the <code>jcf.curve_fit</code> method.</p> <code>initial_dict</code> <code>Dict[str, Any]</code> <p>key word arguments for <code>make_initial_guess</code> method.</p> <code>A_guess_relative</code> <code>bool</code> <p>whether to multiply the initial guess of the amplitude by the peak strain of the waveform.</p> <code>set_seed</code> <code>int</code> <p>random seed for generating the initial guesses. </p> <code>weighted</code> <code>bool</code> <p>whether to perform a weighted fit. </p> <code>double_skip</code> <code>bool</code> <p>whether to skip the next <code>2^n</code> <code>t0</code> fits when a fit does not converge, where <code>n</code> is the number of times the fit did not converge consecutively.</p> <code>skip_i_init</code> <code>int</code> <p>number of <code>t0</code> fits to skip for the first time a nonconvergent fit occured.</p> <code>result_full</code> <code>QNMFitVaryingStartingTimeResult</code> <p><code>QNMFitVaryingStartingTimeResult</code> object for storing the fit results.</p> <p>Methods:</p> Name Description <code>get_mirror_ratio_list</code> <p>get <code>mirror_ratio_list</code> from <code>iota</code> and <code>psi</code>.</p> <code>initial_guesses</code> <p>generate initial guesses for the first <code>t0</code> fit.</p> <code>make_nan_result</code> <p>generate a <code>QNMFitVaryingStartingTimeResult</code> object</p> <code>with `nan` values. do_fits</code> <p>perform the fits.</p>"},{"location":"api/fit/#jaxqualin.fit.QNMFitVaryingStartingTime.__init__","title":"<code>__init__(h, t0_arr, N_free=0, qnm_fixed_list=[], qnm_free_list=[], var_M_a=False, Schwarzschild=False, run_string_prefix='Default', params0=None, max_nfev=200000, sequential_guess=True, load_pickle=True, fit_save_prefix=FIT_SAVE_PATH, nonconvergence_cut=False, A_bound=np.inf, jcf=None, fit_kwargs={}, initial_num=1, random_initial=False, initial_dict={}, A_guess_relative=True, set_seed=1234, weighted=False, double_skip=True, include_mirror=False, iota=None, psi=None, mirror_ignore_phase=True, skip_i_init=1, save_results=True)</code>","text":"<p>Initialize the <code>QNMFitVaryingStartingTime</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>waveform</code> <p>waveform object to be fitted.</p> required <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting.</p> required <code>N_free</code> <code>int</code> <p>number of frequency-free QNMs to include in the model. These modes are completely free, i.e. their mode numbers are not fixed like those in <code>qnm_free_list</code>.</p> <code>0</code> <code>qnm_fixed_list</code> <code>List[mode]</code> <p>list of fixed-frequency QNMs included in the model.</p> <code>[]</code> <code>qnm_free_list</code> <code>List[mode_free]</code> <p>list of free-frequency QNMs of fixed mode numbers to include in the model, only used for fitting <code>M</code> and <code>a</code> when <code>var_M_a = True</code>.</p> <code>[]</code> <code>var_M_a</code> <code>bool</code> <p>fit for the mass and spin of the black hole. Warning: Not tested yet.</p> <code>False</code> <code>Schwarzschild</code> <code>bool</code> <p>whether to fit for Schwarzschild black hole, i.e. real waveform.</p> <code>False</code> <code>run_string_prefix</code> <code>str</code> <p>prefix of the run name for dumping the <code>pickle</code> file.</p> <code>'Default'</code> <code>params0</code> <code>Optional[ndarray]</code> <p>initial guess for the fit parameters, at least for the earliest <code>t0</code> fit.</p> <code>None</code> <code>max_nfev</code> <code>int</code> <p>maximum number of function evaluations for the fit.</p> <code>200000</code> <code>sequential_guess</code> <code>bool</code> <p>whether to use the previous fit as the initial guess for the next fit.</p> <code>True</code> <code>load_pickle</code> <code>bool</code> <p>whether to load the <code>pickle</code> file if it exists.</p> <code>True</code> <code>fit_save_prefix</code> <code>str</code> <p>prefix of the path to save the <code>pickle</code> file.</p> <code>FIT_SAVE_PATH</code> <code>nonconvergence_cut</code> <code>bool</code> <p>whether to cut the nonconverged fits.</p> <code>False</code> <code>A_bound</code> <code>float</code> <p>maximum value of the amplitude.</p> <code>inf</code> <code>jcf</code> <code>Optional[CurveFit]</code> <p><code>jaxfit</code> curve fit object.</p> <code>None</code> <code>fit_kwargs</code> <code>Dict</code> <p>keyword arguments for the <code>jcf.curve_fit</code> method.</p> <code>{}</code> <code>initial_num</code> <code>int</code> <p>number of initial guesses to use for the first starting time for frequency-free fits.</p> <code>1</code> <code>random_initial</code> <code>bool</code> <p>whether to generate random initial guesses for the first starting time for frequency-free fits.</p> <code>False</code> <code>initial_dict</code> <code>Dict</code> <p>key word arguments for <code>make_initial_guess</code> method.</p> <code>{}</code> <code>A_guess_relative</code> <code>bool</code> <p>whether to multiply the initial guess of the amplitude by the peak strain of the waveform.</p> <code>True</code> <code>set_seed</code> <code>int</code> <p>random seed for generating the initial guesses.</p> <code>1234</code> <code>weighted</code> <code>bool</code> <p>whether to perform a weighted fit.</p> <code>False</code> <code>double_skip</code> <code>bool</code> <p>whether to skip the next <code>2^n</code> <code>t0</code> fits when a fit does not converge, where <code>n</code> is the number of times the fit did not converge consecutively.</p> <code>True</code> <code>include_mirror</code> <code>bool</code> <p>whether to include the mirror modes, for fitting waveforms with both waveform polarizations.</p> <code>False</code> <code>iota</code> <code>Optional[float]</code> <p>inclination angle of the source.</p> <code>None</code> <code>psi</code> <code>Optional[float]</code> <p>polarization angle of the source.</p> <code>None</code> <code>mirror_ignore_phase</code> <code>bool</code> <p>whether to ignore the phase difference between the prograde and mirror modes.</p> <code>True</code> <code>skip_i_init</code> <code>int</code> <p>number of <code>t0</code> fits to skip for the first time a nonconvergent fit occured.</p> <code>1</code> <code>save_results</code> <code>bool</code> <p>whether to save the results.</p> <code>True</code>"},{"location":"api/fit/#jaxqualin.fit.QNMFitVaryingStartingTime.do_fits","title":"<code>do_fits(jcf=None, return_jcf=False)</code>","text":"<p>Perform the fits.</p> <p>Parameters:</p> Name Type Description Default <code>jcf</code> <code>Optional[CurveFit]</code> <p><code>jaxfit</code> curve fit object.</p> <code>None</code> <code>return_jcf</code> <code>bool</code> <p>whether to return the <code>jaxfit</code> curve fit object.</p> <code>False</code>"},{"location":"api/fit/#jaxqualin.fit.QNMFitVaryingStartingTime.get_mirror_ratio_list","title":"<code>get_mirror_ratio_list()</code>","text":"<p>Get the ratios between the prograde and mirror modes from <code>iota</code> and <code>psi</code>.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>list of ratios between prograde and mirror mode amplitudes.</p>"},{"location":"api/fit/#jaxqualin.fit.QNMFitVaryingStartingTime.initial_guesses","title":"<code>initial_guesses(jcf=None)</code>","text":"<p>Generate initial guesses for the first <code>t0</code> fit.</p> <p>Parameters:</p> Name Type Description Default <code>jcf</code> <code>Optional[CurveFit]</code> <p><code>jaxfit</code> curve fit object.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>best_guess_index</code> <code>int</code> <p>index of the best initial guess.</p> <code>qnm_fit_list</code> <code>List[QNMFit]</code> <p>list of <code>QNMFit</code> objects for the initial guesses.</p> <code>guess_list</code> <code>List[ndarray]</code> <p>list of initial guess parameters used.</p>"},{"location":"api/fit/#jaxqualin.fit.QNMFitVaryingStartingTime.make_nan_result","title":"<code>make_nan_result()</code>","text":"<p>Generate a <code>QNMFitVaryingStartingTimeResult</code> object with <code>nan</code> values.</p>"},{"location":"api/qnmode/","title":"API for the <code>jaxqualin.qnmode</code> module","text":""},{"location":"api/qnmode/#jaxqualin.qnmode.mode","title":"<code>mode</code>","text":"<p>             Bases: <code>mode_free</code></p> <p>A class representing a frequency-fixed mode of a black hole.</p> <p>Attributes:</p> Name Type Description <code>M</code> <code>float</code> <p>The mass of the black hole.</p> <code>a</code> <code>float</code> <p>The spin parameter of the black hole.</p> <code>retro_def_orbit</code> <code>bool</code> <p>Whether define retrograde modes with respect to the orbital frame (<code>True</code>) or remnant black hole frame (<code>False</code>). See the methods paper for details.</p>"},{"location":"api/qnmode/#jaxqualin.qnmode.mode_free","title":"<code>mode_free</code>","text":"<p>A class representing a mode of a black hole.</p> <p>Attributes:</p> Name Type Description <code>lmnx</code> <code>Union[List[List[int]], str]</code> <p>A list of lists of integers representing the mode numbers, or a string equal to <code>constant</code>. Each list of integers represents a constituent linear mode, and the list of lists represents a nonlinear mode if <code>len(lmnx) &gt; 1</code>. For example, <code>[[2, 2, 0], [3, 3, 0]]</code> represents the <code>2,2,0x3,3,0</code> quadratic mode.</p> <code>spinseq_list</code> <code>List[KerrSpinSeq]</code> <p>A list of <code>qnm.spinsequence.KerrSpinSeq</code> objects of the <code>qnm</code> package that maps the spin parameter <code>a</code> of the black hole into the QNM frequencies.</p> <code>spinseq_list_neg_a</code> <code>List[KerrSpinSeq]</code> <p>Same as <code>spinseq_list</code> but for the retrograde branch of the QNM solution.</p> <code>omegar</code> <code>float</code> <p>The real part of the QNM , if fixed. <code>jaxlib.xla_extension.ArrayImpl</code> of a single <code>jnp.float64</code>.</p> <code>omegai</code> <code>float</code> <p>The imaginary part of the QNM frequency, if fixed. <code>jaxlib.xla_extension.ArrayImpl</code> of a single <code>jnp.float64</code>.</p> <code>omega</code> <code>complex</code> <p>The complex QNM frequency, if fixed. <code>jaxlib.xla_extension.ArrayImpl</code> of a single <code>jnp.complex128</code>.</p> <code>M</code> <code>float</code> <p>The mass of the black hole, if fixed.</p> <code>a</code> <code>float</code> <p>The spin parameter of the black hole, if fixed.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes a mode_free object. </p> <code>fix_mode</code> <p>Fixes the complex frequency of the mode.</p>"},{"location":"api/qnmode/#jaxqualin.qnmode.mode_free.__init__","title":"<code>__init__(lmnx, s=-2)</code>","text":"<p>Initializes a mode_free object.</p> <p>Parameters:</p> Name Type Description Default <code>lmnx</code> <code>Union[List[List[int]], str]</code> <p>A list of lists of integers representing the mode numbers, or a string equal to <code>constant</code>. Each list of integers represents a constituent linear mode, and the list of lists represents a nonlinear mode if <code>len(lmnx) &gt; 1</code>. For example, <code>[[2, 2, 0], [3, 3, 0]]</code> represents the <code>2,2,0x3,3,0</code> quadratic mode.</p> required <code>s</code> <code>int</code> <p>The spin weight of the mode. Defaults to -2.</p> <code>-2</code>"},{"location":"api/qnmode/#jaxqualin.qnmode.mode_free.fix_mode","title":"<code>fix_mode(M, a, retro_def_orbit=True)</code>","text":"<p>Fixes the complex frequency of the mode.</p> <p>Parameters:</p> Name Type Description Default <code>M</code> <code>float</code> <p>The mass of the black hole.</p> required <code>a</code> <code>float</code> <p>The spin parameter of the black hole.</p> required <code>retro_def_orbit</code> <code>bool</code> <p>Whether to define retrograde modes with respect to the orbital frame (<code>True</code>) or remnant black hole frame (<code>False</code>). See the methods paper for details. Defaults to True.</p> <code>True</code>"},{"location":"api/qnmode/#jaxqualin.qnmode.mode_free.is_overtone","title":"<code>is_overtone()</code>","text":"<p>Determines whether the mode is an overtone.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the mode is an overtone.</p>"},{"location":"api/qnmode/#jaxqualin.qnmode.mode_free.string","title":"<code>string()</code>","text":"<p>Returns a string representation of the mode numbers.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the mode numbers.</p>"},{"location":"api/qnmode/#jaxqualin.qnmode.mode_free.sum_lm","title":"<code>sum_lm()</code>","text":"<p>Returns the sum of the mode quantum numbers of constituent linear modes.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>The sum of the mode quantum numbers of constituent linear modes.</p>"},{"location":"api/qnmode/#jaxqualin.qnmode.mode_free.tex_string","title":"<code>tex_string()</code>","text":"<p>Returns a TeX string representation of the mode numbers.</p> <p>Returns:</p> Type Description <code>str</code> <p>A TeX string representation of the mode numbers.</p>"},{"location":"api/selection/","title":"API for the <code>jaxqualin.selection</code> module","text":""},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingN","title":"<code>ModeSearchAllFreeVaryingN</code>","text":"<p>A class that performs a mode search for a given waveform, varying the number of free modes used in the fit.</p> <p>Attributes:</p> Name Type Description <code>h</code> <code>waveform</code> <p>The waveform to be fit.</p> <code>l</code> <code>int</code> <p>The harmonic number l of the waveform.</p> <code>m</code> <code>int</code> <p>The harmonic number m of the waveform.</p> <code>M</code> <code>float</code> <p>The mass of the black hole.</p> <code>a</code> <code>float</code> <p>The dimensionless spin of the black hole.</p> <code>relevant_lm_list</code> <code>List[Tuple[int, int]]</code> <p>A list of tuples of the form (l, m) that specifies which recoil modes are relevant for the waveform.</p> <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting.</p> <code>N_list</code> <code>List[int]</code> <p>A list of integers that specifies the number of free modes to be used in each mode searcher in <code>mode_searchers</code>.</p> <code>kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments.</p> <code>flatness_checker_kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments for the <code>IterativeFlatnessChecker</code> class.</p> <code>mode_searcher_kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments for the <code>ModeSearchAllFreeLM</code> class.</p> <code>mode_searchers</code> <code>List[ModeSearchAllFreeLM]</code> <p>A list of <code>ModeSearchAllFreeLM</code> objects for mode searching with different number of free modes.</p> <code>found_modes_final</code> <code>List[mode]</code> <p>A list of <code>mode</code> objects that contains the final list of modes found by the best mode searcher.</p> <code>run_string_prefix</code> <code>str</code> <p>A string that is used as a prefix for the run name for dumping the <code>pickle</code> file.</p> <code>load_pickle</code> <code>bool</code> <p>A boolean that specifies whether to load the <code>pickle</code> file.</p> <code>CCE</code> <code>bool</code> <p>A boolean that specifies whether the waveform is a CCE waveform. This is not implemented yet.</p> <code>fixed_fitters</code> <code>List[QNMFitVaryingStartingTime]</code> <p>A list of <code>QNMFitVaryingStartingTime</code> objects that contains the final list of fitters used for the flatness checkers in each mode searcher.</p> <code>flatness_checkers</code> <code>List[IterativeFlatnessChecker]</code> <p>A list of <code>IterativeFlatnessChecker</code> objects that contains the list of flatness checkers used for the mode searchers.</p> <code>best_run_indx</code> <code>int</code> <p>An integer that specifies the index of the mode searcher that found the most number of modes.</p> <p>Methods:</p> Name Description <code>init_searchers</code> <p>Initializes the mode searchers. </p> <code>do_mode_searches</code> <p>Performs the mode searches.</p>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingN.__init__","title":"<code>__init__(h, M, a, relevant_lm_list=[], t0_arr=np.linspace(0, 50, num=501), flatness_checker_kwargs={}, mode_searcher_kwargs={}, **kwargs_in)</code>","text":"<p>Initialize the <code>ModeSearchAllFreeVaryingN</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>waveform</code> <p>The waveform to be fit.</p> required <code>M</code> <code>float</code> <p>The mass of the black hole.</p> required <code>a</code> <code>float</code> <p>The dimensionless spin of the black hole.</p> required <code>relevant_lm_list</code> <code>List[Tuple[int, int]]</code> <p>A list of tuples of the form (l, m) that specifies which recoil modes are relevant for the waveform.</p> <code>[]</code> <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting.</p> <code>linspace(0, 50, num=501)</code> <code>flatness_checker_kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments for the <code>IterativeFlatnessChecker</code> class.</p> <code>{}</code> <code>mode_searcher_kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments for the <code>ModeSearchAllFreeLM</code> class.</p> <code>{}</code> <code>**kwargs_in</code> <code>Any</code> <p>keyword arguments.</p> <code>{}</code>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingN.do_mode_searches","title":"<code>do_mode_searches()</code>","text":"<p>Performs the mode searches.</p>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingN.init_searchers","title":"<code>init_searchers()</code>","text":"<p>Initializes the mode searchers.</p>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS","title":"<code>ModeSearchAllFreeVaryingNSXS</code>","text":"<p>A class that performs a mode search for a given SXS waveform, varying the number of free modes used in the fit.</p> <p>Attributes:</p> Name Type Description <code>SXSnum</code> <code>str</code> <p>The SXS number of the waveform. </p> <code>l</code> <code>int</code> <p>The harmonic number l of the</p> <code>waveform.</code> <code>m</code> <p>The harmonic number m of the waveform. </p> <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting. </p> <code>N_list</code> <code>List[int]</code> <p>A list of integers that specifies the number of free modes to be used in each mode searcher in <code>mode_searchers</code>.</p> <code>postfix_string</code> <code>str</code> <p>A string that is appended to the run name for dumping the <code>pickle</code> file.</p> <code>CCE</code> <code>bool</code> <p>A boolean that specifies whether the waveform is a CCE waveform. This is not implemented yet.</p> <code>kwargs</code> <code>Dict[str, Any]</code> <p>A dictionary of keyword arguments. </p> <code>retro_def_orbit</code> <code>bool</code> <p>Whether to define retrograde modes with respect to the orbital frame (<code>True</code>) or remnant black hole frame (<code>False</code>). See the methods paper for details. Defaults to True.</p> <code>relevant_lm_list_override</code> <code>bool</code> <p>A boolean that specifies whether to override the <code>relevant_lm_list</code> attribute of the <code>ModeSearchAllFreeVaryingN</code> class.</p> <code>relevant_lm_list</code> <code>List[Tuple[int, int]]</code> <p>A list of tuples of the form (l, m) that specifies which recoil modes are relevant for the waveform. Used if <code>relevant_lm_list_override</code> is <code>True</code>.</p> <code>h</code> <code>waveform</code> <p>The waveform to be fit. </p> <code>M</code> <code>float</code> <p>The mass of the black hole. </p> <code>a</code> <code>float</code> <p>The dimensionless spin of the black hole. </p> <code>Lev</code> <code>int</code> <p>The resolution level of the SXS simulation. </p> <code>N_list_string</code> <code>str</code> <p>A string that is used as a suffix for the run name for dumping the <code>pickle</code> file.</p> <code>run_string_fitter</code> <code>str</code> <p>A string that is used as a prefix for the run name for dumping the <code>pickle</code> file for the fitters.</p> <code>run_string</code> <code>str</code> <p>A string that is used as a prefix for the run name for dumping the <code>pickle</code> file for the mode searcher.</p> <code>run_string_full</code> <code>str</code> <p>A string that is used as a prefix for the run name for dumping the <code>pickle</code> file for the mode searcher, including the <code>postfix_string</code>.</p> <code>file_path</code> <code>str</code> <p>The path to the <code>pickle</code> file. </p> <code>load_pickle</code> <code>bool</code> <p>A boolean that specifies whether to load the <code>pickle</code> file for the fitters.</p> <code>mode_searcher_load_pickle</code> <code>bool</code> <p>A boolean that specifies whether to load the <code>pickle</code> file for the mode searcher.</p> <code>set_seed</code> <code>int</code> <p>An integer that specifies the seed for the random number generator.</p> <code>save_mode_searcher</code> <code>bool</code> <p>A boolean that specifies whether to save the mode searcher to a <code>pickle</code> file.</p> <code>mode_searcher_vary_N</code> <code>ModeSearchAllFreeVaryingN</code> <p>A <code>ModeSearchAllFreeVaryingN</code> object that performs the mode search.</p> <code>found_modes_final</code> <code>List[mode]</code> <p>A list of <code>mode</code> objects that contains the final list of modes found by the best mode searcher.</p> <p>Methods:</p> Name Description <code>mode_search_varying_N_sxs</code> <p>Performs the mode searches.</p> <code>do_mode_search_varying_N</code> <p>Performs the mode searches and dumps the class instance to a <code>pickle</code> file. </p> <code>get_waveform</code> <p>Loads the waveform from the SXS catalog. </p> <code>pickle_save</code> <p>Dumps the class instance to a <code>pickle</code> file.</p> <code>pickle_load</code> <p>Check whether a <code>pickle</code> file exists and can be loaded.</p>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.__init__","title":"<code>__init__(SXSnum, l, m, t0_arr=np.linspace(0, 50, num=501), **kwargs_in)</code>","text":"<p>Initialize the <code>ModeSearchAllFreeVaryingNSXS</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>SXSnum</code> <code>str</code> <p>The SXS number of the waveform.</p> required <code>l</code> <code>int</code> <p>The harmonic number l of the waveform.</p> required <code>m</code> <code>int</code> <p>The harmonic number m of the waveform.</p> required <code>t0_arr</code> <code>ndarray</code> <p>array of starting times for fitting.</p> <code>linspace(0, 50, num=501)</code> <code>**kwargs_in</code> <code>Any</code> <p>keyword arguments.</p> <code>{}</code>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.do_mode_search_varying_N","title":"<code>do_mode_search_varying_N()</code>","text":"<p>Performs the mode searches and dumps the class instance to a <code>pickle</code> file.</p>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.get_waveform","title":"<code>get_waveform()</code>","text":"<p>Loads the waveform from the SXS catalog.</p>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.mode_search_varying_N_sxs","title":"<code>mode_search_varying_N_sxs()</code>","text":"<p>Performs the mode searches.</p>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.pickle_exists","title":"<code>pickle_exists()</code>","text":"<p>Check whether a <code>pickle</code> file exists and can be loaded.</p>"},{"location":"api/selection/#jaxqualin.selection.ModeSearchAllFreeVaryingNSXS.pickle_save","title":"<code>pickle_save()</code>","text":"<p>Dump the class instance to a <code>pickle</code> file.</p>"},{"location":"api/waveforms/","title":"API for the <code>jaxqualin.waveforms</code> module","text":""},{"location":"api/waveforms/#jaxqualin.waveforms.waveform","title":"<code>waveform</code>","text":"<p>A class representing a waveform containing a ringdown phase to be fitted.</p> <p>Attributes:</p> Name Type Description <code>fulltime</code> <code>ndarray</code> <p>The full time array of the waveform. </p> <code>fullh</code> <code>ndarray</code> <p>The full complex waveform. </p> <code>peaktime</code> <code>float</code> <p>The time of peak strain <code>jnp.abs(h)</code> of the waveform. </p> <code>peakindx</code> <code>int</code> <p>The array index of the time of peak strain of the waveform.</p> <code>t_peak</code> <code>int</code> <p>The time of peak strain of the waveform. This can be defined by the user and overrides <code>peaktime</code>.</p> <code>time</code> <code>ndarray</code> <p>The time array of the waveform after the peak, starting at <code>t_peak</code> and time shifted such that <code>t_peak = 0</code>.</p> <code>hr</code> <code>ndarray</code> <p>The real part of the waveform after the peak.</p> <code>hi</code> <code>ndarray</code> <p>The imaginary part of the waveform after the peak. </p> <code>h</code> <code>ndarray</code> <p>The complex waveform after the peak.</p> <code>l</code> <code>int</code> <p>The spherical harmonic mode number l of the waveform. </p> <code>m</code> <code>int</code> <p>The spherical harmonic mode number m of the waveform.</p> <p>Methods:</p> Name Description <code>update_peaktime</code> <p>Sets <code>t_peak</code> to override the peak time. </p> <code>argabsmax</code> <p>Returns the array index of the time of peak strain of the  waveform.</p> <code>postmerger</code> <p>Returns the time, real part, and imaginary part of the waveform after the peak. </p> <code>set_lm</code> <p>Sets the spherical harmonic mode numbers l and m of the  waveform.</p>"},{"location":"api/waveforms/#jaxqualin.waveforms.waveform.__init__","title":"<code>__init__(fulltime, fullh, t_peak=None, t_start=0.0, t_end=np.inf, l=None, m=None, remove_num=500)</code>","text":"<p>Initialize a waveform.</p> <p>Parameters:</p> Name Type Description Default <code>fulltime</code> <code>ndarray</code> <p>The full time array of the waveform.</p> required <code>fullh</code> <code>ndarray</code> <p>The full complex waveform.</p> required <code>t_peak</code> <code>Optional[float]</code> <p>The time of peak strain of the waveform. This can be defined by the user and overrides <code>peaktime</code>.</p> <code>None</code> <code>t_start</code> <code>float</code> <p>The time after the peak to start the waveform.</p> <code>0.0</code> <code>t_end</code> <code>float</code> <p>The time after the peak to end the waveform.</p> <code>inf</code> <code>l</code> <code>int</code> <p>The spherical harmonic mode number l of the waveform.</p> <code>None</code> <code>m</code> <code>int</code> <p>The spherical harmonic mode number m of the waveform.</p> <code>None</code> <code>remove_num</code> <code>int</code> <p>The number of points to remove from the beginning of the waveform to avoid numerical artifacts.</p> <code>500</code>"},{"location":"api/waveforms/#jaxqualin.waveforms.waveform.argabsmax","title":"<code>argabsmax(remove_num=500)</code>","text":"<p>Returns the array index of the time of peak strain of the waveform.</p> <p>Parameters:</p> Name Type Description Default <code>remove_num</code> <code>int</code> <p>The number of points to remove from the beginning of the waveform to avoid numerical artifacts.</p> <code>500</code> <p>Returns:</p> Type Description <code>int</code> <p>The array index of the time of peak strain of the waveform.</p>"},{"location":"api/waveforms/#jaxqualin.waveforms.waveform.postmerger","title":"<code>postmerger(t_start, t_end=np.inf)</code>","text":"<p>Returns the time, real part, and imaginary part of the waveform after the peak.</p> <p>Parameters:</p> Name Type Description Default <code>t_start</code> <code>float</code> <p>The time after the peak to start the waveform. t_end: The time after the peak to end the waveform.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The time, real part, and imaginary part of the waveform after the</p> <code>ndarray</code> <p>peak.</p>"},{"location":"api/waveforms/#jaxqualin.waveforms.waveform.set_lm","title":"<code>set_lm(l, m)</code>","text":"<p>Sets the spherical harmonic mode numbers l and m of the waveform.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>int</code> <p>The spherical harmonic mode number l of the waveform.</p> required <code>m</code> <code>int</code> <p>The spherical harmonic mode number m of the waveform.</p> required"},{"location":"api/waveforms/#jaxqualin.waveforms.waveform.update_peaktime","title":"<code>update_peaktime(t_peak)</code>","text":"<p>Override the peak time of the waveform.</p> <p>Parameters:</p> Name Type Description Default <code>t_peak</code> <code>float</code> <p>The user-defined peak time of the waveform.</p> required"},{"location":"api/waveforms/#jaxqualin.waveforms.get_SXS_waveform_summed","title":"<code>get_SXS_waveform_summed(SXSnum, iota, psi, l_max=4, res=0, N_ext=2)</code>","text":"<p>Obtain the waveform of a SXS simulation summed over all modes up to l_max.</p> <p>Parameters:</p> Name Type Description Default <code>SXSnum</code> <code>str</code> <p>The SXS simulation number.</p> required <code>iota</code> <code>float</code> <p>The inclination angle of the binary.</p> required <code>psi</code> <code>float</code> <p>The phase to use.</p> required <code>l_max</code> <code>int</code> <p>The maximum l mode to include in the waveform.</p> <code>4</code> <code>res</code> <code>int</code> <p>The level of the simulation, relative to the highest resolution level  (<code>res = 0</code> means highest resolution). Must be zero or negative.</p> <code>0</code> <code>N_ext</code> <code>int</code> <p>The extrapolation order of the simulation.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>h</code> <code>waveform</code> <p>The waveform.</p> <code>Mf</code> <code>float</code> <p>The final mass of the binary.</p> <code>af</code> <code>float</code> <p>The final spin of the binary.</p>"},{"location":"mode_md/-2.1.0/","title":"r2,1,0 mode","text":""},{"location":"mode_md/-2.1.0/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/-2.1.0/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{r2{,}1{,}0} = &amp; \\ 0.1296 - 1.154 \\eta - 0.2453 \\chi_+ - 0.2317 \\chi_- + 3.926 \\eta^2 \\\\   &amp; + 1.853 \\eta \\chi_+ + 1.817 \\eta \\chi_- + 0.07881 \\chi_+^2 + 0.1893 \\chi_+ \\chi_- + 0.1375 \\chi_-^2 \\\\   &amp; - 4.87 \\eta^3 - 4.418 \\eta^2 \\chi_+ - 4.325 \\eta^2 \\chi_- - 0.2036 \\eta \\chi_+^2 \\\\   &amp; - 0.512 \\eta \\chi_+ \\chi_- - 0.625 \\eta \\chi_-^2 + 0.01958 \\chi_+^3 - 0.1001 \\chi_+^2 \\chi_- \\\\   &amp; - 0.02319 \\chi_-^3 \\end{aligned}\\]"},{"location":"mode_md/-2.1.0/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{r2{,}1{,}0} = &amp; \\ 9.191 - 21.01 \\eta + 3.961 \\chi_+ + 11.53 \\eta^2 \\\\   &amp; - 0.5383 \\eta \\chi_- + 3.039 \\chi_+^2 + 3.905 \\chi_+ \\chi_- + 0.8355 \\chi_-^2 \\\\   &amp; - 13.01 \\eta \\chi_+ \\chi_- + 1.6 \\chi_+^3 + 1.932 \\chi_+ \\chi_-^2 \\end{aligned}\\]"},{"location":"mode_md/-2.1.0/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/-2.1.0/#fit-error","title":"Fit error","text":""},{"location":"mode_md/-2.2.0/","title":"r2,2,0 mode","text":""},{"location":"mode_md/-2.2.0/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/-2.2.0/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{r2{,}2{,}0} = &amp; \\ 0.001657 - 0.07586 \\chi_- + 0.1762 \\eta \\chi_+ + 1.358 \\eta \\chi_- \\\\   &amp; + 0.1103 \\chi_+^2 + 0.1361 \\chi_-^2 - 0.03407 \\eta^3 - 2.147 \\eta^2 \\chi_+ \\\\   &amp; - 7.814 \\eta^2 \\chi_- - 1.334 \\eta \\chi_+^2 - 1.295 \\eta \\chi_-^2 - 0.09387 \\chi_+^3 \\\\   &amp; - 0.01674 \\chi_+ \\chi_-^2 + 5.87 \\eta^3 \\chi_+ + 14.41 \\eta^3 \\chi_- + 3.323 \\eta^2 \\chi_+^2 \\\\   &amp; + 2.948 \\eta^2 \\chi_-^2 + 0.1427 \\eta \\chi_+^3 - 0.03698 \\chi_+^4 \\end{aligned}\\]"},{"location":"mode_md/-2.2.0/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{r2{,}2{,}0} = &amp; \\ 13.14 - 31.89 \\eta + 5.247 \\chi_+ - 3.888 \\chi_- + 12.24 \\eta \\chi_- \\\\   &amp; + 2.571 \\chi_+^2 \\end{aligned}\\]"},{"location":"mode_md/-2.2.0/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/-2.2.0/#fit-error","title":"Fit error","text":""},{"location":"mode_md/2.1.0/","title":"2,1,0 mode","text":""},{"location":"mode_md/2.1.0/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/2.1.0/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{2{,}1{,}0} = &amp; \\ 1.827 - 1.306 \\chi_- + 2.247 \\chi_-^2 - 36.8 \\eta \\chi_-^2 \\\\   &amp; - 2.713 \\chi_+^3 + 3.122 \\chi_+^2 \\chi_- - 567 \\eta^4 - 42.68 \\eta^3 \\chi_+ \\\\   &amp; + 132.1 \\eta^2 \\chi_-^2 + 14.34 \\eta \\chi_+^3 - 17.75 \\eta \\chi_+^2 \\chi_- - 17.01 \\eta \\chi_-^3 \\\\   &amp; + 2031 \\eta^5 - 636.3 \\eta^4 \\chi_- + 109.2 \\eta^2 \\chi_-^3 - 12.54 \\eta \\chi_+ \\chi_-^3 \\\\   &amp; + 9.589 \\eta \\chi_-^4 \\end{aligned}\\]"},{"location":"mode_md/2.1.0/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{2{,}1{,}0} = &amp; \\ 3.713 + 13.14 \\eta - 0.6355 \\chi_+ - 0.4104 \\chi_- - 69.94 \\eta^2 \\\\   &amp; + 1.467 \\eta \\chi_- + 0.6818 \\chi_+^2 - 3.018 \\chi_+ \\chi_- + 0.6753 \\chi_-^2 + 145.5 \\eta^3 \\\\   &amp; - 8.586 \\eta^2 \\chi_+ - 6.127 \\eta \\chi_+^2 + 11.72 \\eta \\chi_+ \\chi_- - 3.573 \\eta \\chi_-^2 \\\\   &amp; - 0.8431 \\chi_+^2 \\chi_- \\end{aligned}\\]"},{"location":"mode_md/2.1.0/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/2.1.0/#fit-error","title":"Fit error","text":""},{"location":"mode_md/2.1.1/","title":"2,1,1 mode","text":""},{"location":"mode_md/2.1.1/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/2.1.1/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{2{,}1{,}1} = &amp; \\ 14.06 - 21.07 \\eta + 18.54 \\eta \\chi_+ - 67.63 \\eta \\chi_- \\end{aligned}\\]"},{"location":"mode_md/2.1.1/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{2{,}1{,}1} = &amp; \\ 2.842 - 0.5356 \\chi_+ + 27.41 \\eta^3 - 4.772 \\eta \\chi_+^2 \\\\   &amp; - 3.9 \\chi_+^2 \\chi_- \\end{aligned}\\]"},{"location":"mode_md/2.1.1/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/2.1.1/#fit-error","title":"Fit error","text":""},{"location":"mode_md/2.2.0/","title":"2,2,0 mode","text":""},{"location":"mode_md/2.2.0/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/2.2.0/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{2{,}2{,}0} = &amp; \\ 4.004 + 1.349 \\chi_+ + 0.333 \\chi_- - 1.325 \\eta^2 - 1.369 \\eta \\chi_- \\\\   &amp; + 2.622 \\chi_+ \\chi_- - 32.74 \\eta^2 \\chi_+ + 4.313 \\eta \\chi_+^2 - 25.18 \\eta \\chi_+ \\chi_- \\\\   &amp; + 83.37 \\eta^3 \\chi_+ - 13.39 \\eta^2 \\chi_+^2 + 58.01 \\eta^2 \\chi_+ \\chi_- - 0.3837 \\eta \\chi_+^3 \\\\   &amp; - 0.2075 \\chi_+^4 \\end{aligned}\\]"},{"location":"mode_md/2.2.0/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{2{,}2{,}0} = &amp; \\ 0 \\end{aligned}\\]"},{"location":"mode_md/2.2.0/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/2.2.0/#fit-error","title":"Fit error","text":""},{"location":"mode_md/2.2.1/","title":"2,2,1 mode","text":""},{"location":"mode_md/2.2.1/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/2.2.1/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{2{,}2{,}1} = &amp; \\ 15.46 - 407 \\eta^2 + 55.43 \\eta \\chi_+ - 413.5 \\eta \\chi_- + 14.82 \\chi_+^2 \\\\   &amp; - 65.08 \\chi_+ \\chi_- + 17.99 \\chi_-^2 + 1731 \\eta^3 + 4245 \\eta^2 \\chi_- + 876.8 \\eta \\chi_+ \\chi_- \\\\   &amp; - 72.06 \\eta \\chi_-^2 + 11.46 \\chi_+^3 + 101.2 \\chi_+ \\chi_-^2 - 2.499 \\chi_-^3 \\\\   &amp; - 10310 \\eta^3 \\chi_- - 2485 \\eta^2 \\chi_+ \\chi_- - 400 \\eta \\chi_+ \\chi_-^2 \\end{aligned}\\]"},{"location":"mode_md/2.2.1/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{2{,}2{,}1} = &amp; \\ 3.918 + 30.68 \\eta + 1.65 \\chi_+ + 2.251 \\chi_- - 196.8 \\eta^2 \\\\   &amp; - 15.94 \\eta \\chi_+ - 35.86 \\eta \\chi_- - 0.2809 \\chi_+^2 - 2.797 \\chi_+ \\chi_- + 324.6 \\eta^3 \\\\   &amp; + 32.04 \\eta^2 \\chi_+ + 107 \\eta^2 \\chi_- + 11.19 \\eta \\chi_+ \\chi_- - 0.2427 \\chi_+^3 \\end{aligned}\\]"},{"location":"mode_md/2.2.1/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/2.2.1/#fit-error","title":"Fit error","text":""},{"location":"mode_md/3.2.0/","title":"3,2,0 mode","text":""},{"location":"mode_md/3.2.0/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/3.2.0/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{3{,}2{,}0} = &amp; \\ 0.7695 - 3.308 \\eta - 1.446 \\eta \\chi_+ - 61.87 \\eta^3 + 72.14 \\eta^2 \\chi_+ \\\\   &amp; - 127.1 \\eta^2 \\chi_- - 2.769 \\eta \\chi_+ \\chi_- + 0.3681 \\eta \\chi_-^2 - 0.5065 \\chi_+ \\chi_-^2 \\\\   &amp; + 0.5483 \\chi_-^3 + 293.4 \\eta^4 - 527.6 \\eta^3 \\chi_+ + 1110 \\eta^3 \\chi_- \\\\   &amp; + 11.14 \\eta^2 \\chi_+ \\chi_- + 2.18 \\eta \\chi_+ \\chi_-^2 - 2.023 \\eta \\chi_-^3 + 1014 \\eta^4 \\chi_+ \\\\   &amp; - 2407 \\eta^4 \\chi_- \\end{aligned}\\]"},{"location":"mode_md/3.2.0/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{3{,}2{,}0} = &amp; \\ - 32.08 + 889.7 \\eta - 81.88 \\chi_+ + 93.05 \\chi_- - 9292 \\eta^2 \\\\   &amp; + 1584 \\eta \\chi_+ - 1817 \\eta \\chi_- - 0.3888 \\chi_-^2 + 40350 \\eta^3 - 9588 \\eta^2 \\chi_+ \\\\   &amp; + 10930 \\eta^2 \\chi_- - 6.121 \\eta \\chi_+^2 - 60250 \\eta^4 + 18190 \\eta^3 \\chi_+ \\\\   &amp; - 20600 \\eta^3 \\chi_- \\end{aligned}\\]"},{"location":"mode_md/3.2.0/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/3.2.0/#fit-error","title":"Fit error","text":""},{"location":"mode_md/3.3.0/","title":"3,3,0 mode","text":""},{"location":"mode_md/3.3.0/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/3.3.0/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{3{,}3{,}0} = &amp; \\ 1.748 + 1.982 \\eta + 0.5514 \\chi_+ + 0.4317 \\chi_- + 0.7544 \\chi_+^2 \\\\   &amp; + 0.09998 \\chi_-^2 - 4.293 \\eta^2 \\chi_- - 2.133 \\eta \\chi_+^2 + 0.2599 \\chi_+^2 \\chi_- \\end{aligned}\\]"},{"location":"mode_md/3.3.0/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{3{,}3{,}0} = &amp; \\ 0.01279 - 0.9859 \\chi_- + 10.18 \\eta^2 + 1.334 \\eta \\chi_+ \\\\   &amp; + 15.64 \\eta \\chi_- - 56.52 \\eta^2 \\chi_- \\end{aligned}\\]"},{"location":"mode_md/3.3.0/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/3.3.0/#fit-error","title":"Fit error","text":""},{"location":"mode_md/3.3.1/","title":"3,3,1 mode","text":""},{"location":"mode_md/3.3.1/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/3.3.1/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{3{,}3{,}1} = &amp; \\ - 10.37 + 85.12 \\chi_+ + 322.3 \\chi_- + 4845 \\eta^2 - 988.1 \\eta \\chi_+ \\\\   &amp; - 5586 \\eta \\chi_- - 78.67 \\chi_+^2 - 373.2 \\chi_+ \\chi_- - 38270 \\eta^3 + 2968 \\eta^2 \\chi_+ \\\\   &amp; + 31740 \\eta^2 \\chi_- + 453.9 \\eta \\chi_+^2 + 4124 \\eta \\chi_+ \\chi_- + 14.41 \\chi_+^3 \\\\   &amp; + 305 \\chi_+^2 \\chi_- + 82530 \\eta^4 - 58260 \\eta^3 \\chi_- - 10660 \\eta^2 \\chi_+ \\chi_- \\\\   &amp; - 1446 \\eta \\chi_+^2 \\chi_- \\end{aligned}\\]"},{"location":"mode_md/3.3.1/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{3{,}3{,}1} = &amp; \\ 5.276 - 2.033 \\chi_- - 23.61 \\eta^2 + 24.91 \\eta \\chi_- \\\\   &amp; - 0.6914 \\chi_+ \\chi_- + 81.93 \\eta^3 - 84.18 \\eta^2 \\chi_- - 0.636 \\chi_+^2 \\chi_- \\end{aligned}\\]"},{"location":"mode_md/3.3.1/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/3.3.1/#fit-error","title":"Fit error","text":""},{"location":"mode_md/4.4.0/","title":"4,4,0 mode","text":""},{"location":"mode_md/4.4.0/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/4.4.0/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{4{,}4{,}0} = &amp; \\ 0.6505 + 2.978 \\eta \\chi_- + 0.4262 \\chi_+ \\chi_- + 106.1 \\eta^3 \\\\   &amp; + 67.45 \\eta^2 \\chi_+ - 12.08 \\eta^2 \\chi_- - 1.738 \\eta \\chi_+ \\chi_- - 2041 \\eta^4 \\\\   &amp; - 614.2 \\eta^3 \\chi_+ + 5974 \\eta^5 + 1387 \\eta^4 \\chi_+ \\end{aligned}\\]"},{"location":"mode_md/4.4.0/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{4{,}4{,}0} = &amp; \\ 153.6 - 6463 \\eta + 114700 \\eta^2 - 1053000 \\eta^3 \\\\   &amp; + 5278000 \\eta^4 + 478.4 \\eta^3 \\chi_+ - 13680000 \\eta^5 - 1960 \\eta^4 \\chi_+ \\\\   &amp; + 65.4 \\eta^4 \\chi_- + 14320000 \\eta^6 \\end{aligned}\\]"},{"location":"mode_md/4.4.0/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/4.4.0/#fit-error","title":"Fit error","text":""},{"location":"mode_md/5.5.0/","title":"5,5,0 mode","text":""},{"location":"mode_md/5.5.0/#fit-expressions","title":"Fit expressions","text":"<p>The hyperfit expressions should be used with caution, especially in regions of low amplitude or outside of the convex hull of the data points. The hyperfit function for the amplitude could go to negative values in these regions, which is unphysical. The phase data has been unwrapped before fitting to the best of our ability, but there may still be some jumps of \\(2\\pi\\) in the data, which could be seen in the error plot. Please consult the fit error plot on the bottom of this page before using the fits.</p> <p>We also recommend checking the hyperfit results against the interpolated results.  Please check the example notebook under the Examples tab.</p>"},{"location":"mode_md/5.5.0/#amplitude","title":"Amplitude","text":"\\[\\begin{aligned} A_{5{,}5{,}0} = &amp; \\ 0.402 + 0.1177 \\chi_-^2 + 65.85 \\eta^2 \\chi_- - 885.7 \\eta^4 \\\\   &amp; - 626.1 \\eta^3 \\chi_- + 3532 \\eta^5 + 1495 \\eta^4 \\chi_- \\end{aligned}\\]"},{"location":"mode_md/5.5.0/#phase","title":"Phase","text":"\\[\\begin{aligned} \\phi_{5{,}5{,}0} = &amp; \\ 6.25 + 155.6 \\eta^2 \\chi_- - 791.3 \\eta^3 \\chi_- - 27350 \\eta^6 \\\\   &amp; + 139 \\eta^3 \\chi_-^3 \\end{aligned}\\]"},{"location":"mode_md/5.5.0/#interactive-plot","title":"Interactive plot","text":"<p>Click on the buttons below to switch between the amplitude, phase and starting time plots.</p>"},{"location":"mode_md/5.5.0/#fit-error","title":"Fit error","text":""},{"location":"notebooks/example_custom_waveform/","title":"Custom waveform","text":"In\u00a0[1]: Copied! <pre>from jaxqualin.waveforms import delayed_QNM, waveform\nfrom jaxqualin.qnmode import mode, mode_list\nfrom jaxqualin.fit import QNMFitVaryingStartingTime\nfrom jaxqualin.selection import ModeSearchAllFreeVaryingN\nfrom jaxqualin.plot import (plot_amplitudes, plot_phases, \n                            plot_omega_free, plot_predicted_qnms,\n                            plot_mode_searcher_results)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from jaxqualin.waveforms import delayed_QNM, waveform from jaxqualin.qnmode import mode, mode_list from jaxqualin.fit import QNMFitVaryingStartingTime from jaxqualin.selection import ModeSearchAllFreeVaryingN from jaxqualin.plot import (plot_amplitudes, plot_phases,                              plot_omega_free, plot_predicted_qnms,                             plot_mode_searcher_results)  import numpy as np import matplotlib.pyplot as plt <pre>PyCBC.libutils: pkg-config call failed, setting NO_PKGCONFIG=1\n</pre> In\u00a0[2]: Copied! <pre>Mf = 1\naf = 0.7\nmodes = mode_list(['2.2.0', '2.2.1', '3.2.0'], Mf, af)\nA_phi_dict = {'2.2.0': dict(A = 1., phi = 0.),\n              '2.2.1': dict(A = 3., phi = np.pi/2),\n              '3.2.0': dict(A = 1e-2, phi = np.pi)}\n\nt_arr = np.linspace(0, 120, 1000)\nh_arr = np.zeros(t_arr.shape, dtype = np.complex128)\nfor i, mode in enumerate(modes):\n    if i == 0:\n        A_delay = 0\n        A_sig = 10\n        phi_sig = 5\n    else:\n        A_delay = 5\n        A_sig = 2\n        phi_sig = 2\n    h_arr += delayed_QNM(mode, t_arr, \n                         A_phi_dict[mode.string()]['A'], \n                         A_phi_dict[mode.string()]['phi'],\n                         A_delay = A_delay, A_sig = A_sig, phi_sig = phi_sig)\n</pre> Mf = 1 af = 0.7 modes = mode_list(['2.2.0', '2.2.1', '3.2.0'], Mf, af) A_phi_dict = {'2.2.0': dict(A = 1., phi = 0.),               '2.2.1': dict(A = 3., phi = np.pi/2),               '3.2.0': dict(A = 1e-2, phi = np.pi)}  t_arr = np.linspace(0, 120, 1000) h_arr = np.zeros(t_arr.shape, dtype = np.complex128) for i, mode in enumerate(modes):     if i == 0:         A_delay = 0         A_sig = 10         phi_sig = 5     else:         A_delay = 5         A_sig = 2         phi_sig = 2     h_arr += delayed_QNM(mode, t_arr,                           A_phi_dict[mode.string()]['A'],                           A_phi_dict[mode.string()]['phi'],                          A_delay = A_delay, A_sig = A_sig, phi_sig = phi_sig) In\u00a0[3]: Copied! <pre>h = waveform(t_arr, h_arr, t_peak = 0)\n</pre> h = waveform(t_arr, h_arr, t_peak = 0) In\u00a0[4]: Copied! <pre>fig, ax = plt.subplots()\nax.semilogy(h.time, np.abs(h.hr))\nax.set_xlabel(r'$t$')\nax.set_ylabel(r'$|h_r|$')\n</pre> fig, ax = plt.subplots() ax.semilogy(h.time, np.abs(h.hr)) ax.set_xlabel(r'$t$') ax.set_ylabel(r'$|h_r|$') Out[4]: <pre>Text(0, 0.5, '$|h_r|$')</pre> In\u00a0[5]: Copied! <pre>t0_arr = np.linspace(0, 50, num = 101) # array of starting times to fit for\n                                       # t0 = 0 is the peak of the strain\nqnm_fixed_list = [] # list of QNMs with fixed frequencies in the fit model\nrun_string_prefix = f\"custom_example_lm_2.2\" # prefix of pickle file for saving the results\nN_free = 3 # number of free modes to use\n\n# fitter object\nfitter = QNMFitVaryingStartingTime(\n                            h, t0_arr, N_free = N_free,\n                            qnm_fixed_list = qnm_fixed_list, load_pickle = True,\n                            run_string_prefix = run_string_prefix)\n</pre> t0_arr = np.linspace(0, 50, num = 101) # array of starting times to fit for                                        # t0 = 0 is the peak of the strain qnm_fixed_list = [] # list of QNMs with fixed frequencies in the fit model run_string_prefix = f\"custom_example_lm_2.2\" # prefix of pickle file for saving the results N_free = 3 # number of free modes to use  # fitter object fitter = QNMFitVaryingStartingTime(                             h, t0_arr, N_free = N_free,                             qnm_fixed_list = qnm_fixed_list, load_pickle = True,                             run_string_prefix = run_string_prefix) In\u00a0[6]: Copied! <pre># do fits, in series from lowest to highest starting time\n# This takes a little longer to run the first time\nfitter.do_fits()\n</pre> # do fits, in series from lowest to highest starting time # This takes a little longer to run the first time fitter.do_fits() <pre>Runname: custom_example_lm_2.2, fitting for N_free = 3. Status:   0%|          | 0/101 [00:00&lt;?, ?it/s]</pre> In\u00a0[7]: Copied! <pre># fitter results object\nresult = fitter.result_full\n</pre> # fitter results object result = fitter.result_full In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots()\n\n# mode locations to visualize on the plot\npredicted_qnms = mode_list(['2.2.0', '2.2.1', '3.2.0'], Mf, af)\n\nplot_omega_free(result, ax)\nplot_predicted_qnms(ax, predicted_qnms)\n</pre> fig, ax = plt.subplots()  # mode locations to visualize on the plot predicted_qnms = mode_list(['2.2.0', '2.2.1', '3.2.0'], Mf, af)  plot_omega_free(result, ax) plot_predicted_qnms(ax, predicted_qnms) In\u00a0[9]: Copied! <pre>t0_arr = np.linspace(0, 50, num = 101) # array of starting times to fit for\n                                       # t0 = 0 is the peak of the straisn\nqnm_fixed_list = mode_list(['2.2.0', '2.2.1', '3.2.0'],\n                                   Mf, af) # list of QNMs with fixed frequencies in the fit model\nrun_string_prefix = f\"custom_example_lm_2.2\" # prefix of pickle file for saving the results\nN_free = 0 # number of free modes to use\n\n# fitter object\nfitter = QNMFitVaryingStartingTime(\n                            h, t0_arr, N_free = N_free,\n                            qnm_fixed_list = qnm_fixed_list, load_pickle = True,\n                            run_string_prefix = run_string_prefix)\n</pre> t0_arr = np.linspace(0, 50, num = 101) # array of starting times to fit for                                        # t0 = 0 is the peak of the straisn qnm_fixed_list = mode_list(['2.2.0', '2.2.1', '3.2.0'],                                    Mf, af) # list of QNMs with fixed frequencies in the fit model run_string_prefix = f\"custom_example_lm_2.2\" # prefix of pickle file for saving the results N_free = 0 # number of free modes to use  # fitter object fitter = QNMFitVaryingStartingTime(                             h, t0_arr, N_free = N_free,                             qnm_fixed_list = qnm_fixed_list, load_pickle = True,                             run_string_prefix = run_string_prefix) In\u00a0[10]: Copied! <pre>fitter.do_fits()\nresult = fitter.result_full\n</pre> fitter.do_fits() result = fitter.result_full <pre>Runname: custom_example_lm_2.2, fitting with the following modes: 2.2.0, 2.2.1, 3.2.0. Status:   0%|          \u2026</pre> In\u00a0[11]: Copied! <pre>fig, axs = plt.subplots(1, 2, figsize = (12, 5))\nplot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0])\nplot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1], legend = False)\n</pre> fig, axs = plt.subplots(1, 2, figsize = (12, 5)) plot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0]) plot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1], legend = False) In\u00a0[12]: Copied! <pre>h.set_lm(2, 2)\nrelevant_lm_list = [(2,2)]\nrun_string_prefix = f\"custom_example_lm_2.2\" # prefix of pickle file for saving the results\nmode_searcher = ModeSearchAllFreeVaryingN(h, Mf, af, \n                                          relevant_lm_list = relevant_lm_list,\n                                          N_list = [3], \n                                          t0_arr = t0_arr,\n                                          run_string_prefix = run_string_prefix\n                                        )\n</pre> h.set_lm(2, 2) relevant_lm_list = [(2,2)] run_string_prefix = f\"custom_example_lm_2.2\" # prefix of pickle file for saving the results mode_searcher = ModeSearchAllFreeVaryingN(h, Mf, af,                                            relevant_lm_list = relevant_lm_list,                                           N_list = [3],                                            t0_arr = t0_arr,                                           run_string_prefix = run_string_prefix                                         )  In\u00a0[13]: Copied! <pre>mode_searcher.do_mode_searches()\n</pre> mode_searcher.do_mode_searches() <pre>Loaded fit custom_example_lm_2.2_N_3_t0_0.0000_50.0000_101 from an old run.\nRunname: custom_example_lm_2.2, N_free = 3, potential modes: 2.2.1, 3.2.0, 2.2.0\nPerforming amplitude and phase flatness check for N_free = 3\nLoaded fit custom_example_lm_2.2_N_0_fix_2.2.0_2.2.1_3.2.0_t0_0.0000_50.0000_101 from an old run.\nRunname: custom_example_lm_2.2, N_free = 3, found the following 3 modes: \n2.2.1, 3.2.0, 2.2.0\n</pre> In\u00a0[14]: Copied! <pre>plot_mode_searcher_results(mode_searcher)\n</pre> plot_mode_searcher_results(mode_searcher)"},{"location":"notebooks/example_custom_waveform/#example-fitting-your-own-waveform","title":"Example: Fitting your own waveform\u00b6","text":""},{"location":"notebooks/example_custom_waveform/#make-waveform","title":"Make waveform\u00b6","text":"<p>As example, we will make a waveform that contains three QNMs that are distorted close to the merger peak. You can replace this with whatever time domain waveform you would like to fit.</p>"},{"location":"notebooks/example_custom_waveform/#make-waveform-object","title":"Make waveform object\u00b6","text":"<p>You can pass in whatever time domain waveform. If you know that the peak strain is located at t = 0, then pass in <code>t_peak = 0</code>, or else the waveform object detects the peak on its own. If <code>t_peak</code> is not passed, the first <code>remove_num = 500</code> data points are removed by default because BBH merger simulations often contain junk radiation in the beginning. You can set <code>remove_num = 0</code> if you do not want to remove any data points.</p>"},{"location":"notebooks/example_custom_waveform/#free-qnms-unfixed-frequencies","title":"Free QNMs (unfixed frequencies)\u00b6","text":""},{"location":"notebooks/example_custom_waveform/#fixed-qnms-fixed-frequencies","title":"Fixed QNMs (fixed frequencies)\u00b6","text":""},{"location":"notebooks/example_custom_waveform/#mode-search","title":"Mode search\u00b6","text":""},{"location":"notebooks/example_fit/","title":"Fitting the ringdown","text":"In\u00a0[1]: Copied! <pre>from jaxqualin.qnmode import mode, mode_list\nfrom jaxqualin.waveforms import get_waveform_SXS\nfrom jaxqualin.fit import QNMFitVaryingStartingTime\nfrom jaxqualin.plot import plot_amplitudes, plot_phases, plot_omega_free, plot_predicted_qnms\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from jaxqualin.qnmode import mode, mode_list from jaxqualin.waveforms import get_waveform_SXS from jaxqualin.fit import QNMFitVaryingStartingTime from jaxqualin.plot import plot_amplitudes, plot_phases, plot_omega_free, plot_predicted_qnms  import numpy as np import matplotlib.pyplot as plt <pre>PyCBC.libutils: pkg-config call failed, setting NO_PKGCONFIG=1\n</pre> In\u00a0[2]: Copied! <pre>SXSnum = \"0305\"\nl = 2\nm = 2\n\nh, Mf, af, Lev = get_waveform_SXS(SXSnum, l, m)\n</pre> SXSnum = \"0305\" l = 2 m = 2  h, Mf, af, Lev = get_waveform_SXS(SXSnum, l, m) <pre>Skipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nSkipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/rhOverM_Asymptotic_GeometricUnits_CoM.h5\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/metadata.json\n</pre> In\u00a0[3]: Copied! <pre>t0_arr = np.linspace(0, 50, num = 501) # array of starting times to fit for\n                                       # t0 = 0 is the peak of the strain\nqnm_fixed_list = [] # list of QNMs with fixed frequencies in the fit model\nrun_string_prefix = f\"SXS{SXSnum}_lm_{l}.{m}\" # prefix of pickle file for saving the results\nN_free = 3 # number of free modes to use\n\n# fitter object\nfitter = QNMFitVaryingStartingTime(\n                            h, t0_arr, N_free = N_free,\n                            qnm_fixed_list = qnm_fixed_list, load_pickle = True,\n                            run_string_prefix = run_string_prefix)\n</pre> t0_arr = np.linspace(0, 50, num = 501) # array of starting times to fit for                                        # t0 = 0 is the peak of the strain qnm_fixed_list = [] # list of QNMs with fixed frequencies in the fit model run_string_prefix = f\"SXS{SXSnum}_lm_{l}.{m}\" # prefix of pickle file for saving the results N_free = 3 # number of free modes to use  # fitter object fitter = QNMFitVaryingStartingTime(                             h, t0_arr, N_free = N_free,                             qnm_fixed_list = qnm_fixed_list, load_pickle = True,                             run_string_prefix = run_string_prefix) In\u00a0[4]: Copied! <pre># do fits, in series from lowest to highest starting time\n# This takes a little longer to run the first time\nfitter.do_fits()\n</pre> # do fits, in series from lowest to highest starting time # This takes a little longer to run the first time fitter.do_fits() <pre>Runname: SXS0305_lm_2.2, fitting for N_free = 3. Status:   0%|          | 0/501 [00:00&lt;?, ?it/s]</pre> In\u00a0[5]: Copied! <pre># fitter results object\nresult = fitter.result_full\n</pre> # fitter results object result = fitter.result_full In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots()\n\n# mode locations to visualize on the plot\npredicted_qnms = mode_list(['2.2.0', '2.2.1', '3.2.0'], Mf, af)\n\nplot_omega_free(result, ax)\nplot_predicted_qnms(ax, predicted_qnms)\n</pre> fig, ax = plt.subplots()  # mode locations to visualize on the plot predicted_qnms = mode_list(['2.2.0', '2.2.1', '3.2.0'], Mf, af)  plot_omega_free(result, ax) plot_predicted_qnms(ax, predicted_qnms) In\u00a0[7]: Copied! <pre>t0_arr = np.linspace(0, 50, num = 501) # array of starting times to fit for\n                                       # t0 = 0 is the peak of the straisn\nqnm_fixed_list = mode_list(['2.2.0', '2.2.1', '3.2.0'],\n                                   Mf, af) # list of QNMs with fixed frequencies in the fit model\nrun_string_prefix = f\"SXS{SXSnum}_lm_{l}.{m}\" # prefix of pickle file for saving the results\nN_free = 0 # number of free modes to use\n\n# fitter object\nfitter = QNMFitVaryingStartingTime(\n                            h, t0_arr, N_free = N_free,\n                            qnm_fixed_list = qnm_fixed_list, load_pickle = True,\n                            run_string_prefix = run_string_prefix)\n</pre> t0_arr = np.linspace(0, 50, num = 501) # array of starting times to fit for                                        # t0 = 0 is the peak of the straisn qnm_fixed_list = mode_list(['2.2.0', '2.2.1', '3.2.0'],                                    Mf, af) # list of QNMs with fixed frequencies in the fit model run_string_prefix = f\"SXS{SXSnum}_lm_{l}.{m}\" # prefix of pickle file for saving the results N_free = 0 # number of free modes to use  # fitter object fitter = QNMFitVaryingStartingTime(                             h, t0_arr, N_free = N_free,                             qnm_fixed_list = qnm_fixed_list, load_pickle = True,                             run_string_prefix = run_string_prefix) In\u00a0[8]: Copied! <pre>fitter.do_fits()\n</pre> fitter.do_fits() <pre>Runname: SXS0305_lm_2.2, fitting with the following modes: 2.2.0, 2.2.1, 3.2.0. Status:   0%|          | 0/501\u2026</pre> In\u00a0[9]: Copied! <pre>result = fitter.result_full\n</pre> result = fitter.result_full <p>We plot the amplitude and phase of the fixed modes, as a function of $t_0$</p> In\u00a0[10]: Copied! <pre>fig, axs = plt.subplots(1, 2, figsize = (12, 5))\nplot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0])\nplot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1], legend = False)\n</pre> fig, axs = plt.subplots(1, 2, figsize = (12, 5)) plot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0]) plot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1], legend = False)"},{"location":"notebooks/example_fit/#example-fitting-a-waveform-in-the-sxs-catalog","title":"Example: fitting a waveform in the SXS catalog\u00b6","text":""},{"location":"notebooks/example_fit/#import-modules","title":"Import modules\u00b6","text":""},{"location":"notebooks/example_fit/#getting-the-sxs-waveform","title":"Getting the SXS waveform\u00b6","text":"<p>The waveform will be downloaded with the <code>sxs</code> package, if not already.</p>"},{"location":"notebooks/example_fit/#case-1-fit-model-with-free-qnms-unfixed-frequencies","title":"Case 1: Fit model with free QNMs (unfixed frequencies)\u00b6","text":"<p>Here we will fit with three free QNMs ($N_{f} = 3$) and see if the resulting frequencies approach any of the QNMs we expect to find. By default, the fit results are saved with <code>pickle</code> into <code>./.jaxqualin_cache/fits/</code>. If <code>load_pickle</code> is <code>True</code>, the fitter will load the pickled result that matches <code>run_string_prefix</code> and the list of modes used.</p>"},{"location":"notebooks/example_fit/#plotting-the-results","title":"Plotting the results\u00b6","text":"<p>Different colored points trace out the frequency evolution of a free QNM from early to late $t_0$.</p>"},{"location":"notebooks/example_fit/#case-2-fixed-qnms-fixed-frequencies","title":"Case 2: Fixed QNMs (fixed frequencies)\u00b6","text":"<p>Here we assume that the $2{,}2{,}0, 2{,}2{,}1$ and $3{,}3{,}0$ modes are present, so we use a fit model including these three modes and fix their frequencies according to GR with the help of the <code>qnm</code> package. We will use $N_f = 0$, meaning that we do not include additional free QNMs on top of the three fixed modes.</p>"},{"location":"notebooks/example_hyperfit_load/","title":"Loading hyperfits and interpolators","text":"In\u00a0[1]: Copied! <pre>from jaxqualin.data import (download_hyperfit_data, \n                            download_interpolate_data,\n                            make_hyper_fit_functions,\n                            make_interpolators)\n</pre> from jaxqualin.data import (download_hyperfit_data,                              download_interpolate_data,                             make_hyper_fit_functions,                             make_interpolators) In\u00a0[2]: Copied! <pre>download_hyperfit_data()\ndownload_interpolate_data()\n</pre> download_hyperfit_data() download_interpolate_data() <pre>Downloading data file from https://mhycheung.github.io/jaxqualin/data/hyperfit_functions_latest.json to /home/markc/Jaxqualin/docs/notebooks/.jaxqualin_cache/data/hyperfit_functions_latest.json\nDownloading data file from https://mhycheung.github.io/jaxqualin/data/interpolate_data_latest.json to /home/markc/Jaxqualin/docs/notebooks/.jaxqualin_cache/data/interpolate_data_latest.json\n</pre> In\u00a0[3]: Copied! <pre>hyperfit_functions = make_hyper_fit_functions()\nhyper_interpolators = make_interpolators()\n</pre> hyperfit_functions = make_hyper_fit_functions() hyper_interpolators = make_interpolators() In\u00a0[4]: Copied! <pre>mode_name = '2.2.1'\n\neta, chi_p, chi_m = 0.2, 0.1, 0.4\nA_fit = hyperfit_functions[mode_name]['A'](eta, chi_p, chi_m)\nA_interp = hyper_interpolators[mode_name]['A'](eta, chi_p, chi_m)\nphi_fit = hyperfit_functions[mode_name]['phi'](eta, chi_p, chi_m)\nphi_interp = hyper_interpolators[mode_name]['phi'](eta, chi_p, chi_m)\n\nprint(f'A_fit: {A_fit:.5f}, A_interp: {A_interp:.5f}')\nprint(f'phi_fit: {phi_fit:.5f}, phi_interp: {phi_interp:.5f}')\n</pre> mode_name = '2.2.1'  eta, chi_p, chi_m = 0.2, 0.1, 0.4 A_fit = hyperfit_functions[mode_name]['A'](eta, chi_p, chi_m) A_interp = hyper_interpolators[mode_name]['A'](eta, chi_p, chi_m) phi_fit = hyperfit_functions[mode_name]['phi'](eta, chi_p, chi_m) phi_interp = hyper_interpolators[mode_name]['phi'](eta, chi_p, chi_m)  print(f'A_fit: {A_fit:.5f}, A_interp: {A_interp:.5f}') print(f'phi_fit: {phi_fit:.5f}, phi_interp: {phi_interp:.5f}') <pre>A_fit: 3.46540, A_interp: 3.52040\nphi_fit: 4.46984, phi_interp: 4.53029\n</pre> <p>The interpolator returns <code>nan</code> if the requested point is outside of the convex hull of the interpolation data. This can be used to check whether the hyperfit is extrapolating at the point, because the fit is trained with the same data used to construct the interpolator. If the point is not covered by the convex hull, it could be because no simulations in the SXS catalog cover that region of the parameter space, or the mode amplitude is too weak (such that the mode extraction procedure missed the mode).</p> In\u00a0[5]: Copied! <pre>eta, chi_p, chi_m = 0.1, 0.9, -0.9\nA_fit = hyperfit_functions[mode_name]['A'](eta, chi_p, chi_m)\nA_interp = hyper_interpolators[mode_name]['A'](eta, chi_p, chi_m)\nphi_fit = hyperfit_functions[mode_name]['phi'](eta, chi_p, chi_m)\nphi_interp = hyper_interpolators[mode_name]['phi'](eta, chi_p, chi_m)\n\nprint(f'A_fit: {A_fit:.5f}, A_interp: {A_interp:.5f}')\nprint(f'phi_fit: {phi_fit:.5f}, phi_interp: {phi_interp:.5f}')\n</pre> eta, chi_p, chi_m = 0.1, 0.9, -0.9 A_fit = hyperfit_functions[mode_name]['A'](eta, chi_p, chi_m) A_interp = hyper_interpolators[mode_name]['A'](eta, chi_p, chi_m) phi_fit = hyperfit_functions[mode_name]['phi'](eta, chi_p, chi_m) phi_interp = hyper_interpolators[mode_name]['phi'](eta, chi_p, chi_m)  print(f'A_fit: {A_fit:.5f}, A_interp: {A_interp:.5f}') print(f'phi_fit: {phi_fit:.5f}, phi_interp: {phi_interp:.5f}') <pre>A_fit: 10.37139, A_interp: nan\nphi_fit: 6.87546, phi_interp: nan\n</pre> <p>When the hyperfit and interpolation returns significantly different results, care should be taken. The mode amplitude might be too small for the hyperfit to work accurately, and the results in these regions of parameter space should at most be used as an order of magnitude estimation. In fact, the hyperfit amplitude could even be negative, if the mode amplitude is too low.</p> In\u00a0[6]: Copied! <pre>mode_name = '-2.2.0'\n\neta, chi_p, chi_m = 0.2, -0.1, 0.4\nA_fit = hyperfit_functions[mode_name]['A'](eta, chi_p, chi_m)\nA_interp = hyper_interpolators[mode_name]['A'](eta, chi_p, chi_m)\nphi_fit = hyperfit_functions[mode_name]['phi'](eta, chi_p, chi_m)\nphi_interp = hyper_interpolators[mode_name]['phi'](eta, chi_p, chi_m)\n\nprint(f'A_fit: {A_fit:.5e}, A_interp: {A_interp:.5e}')\nprint(f'phi_fit: {phi_fit:.5f}, phi_interp: {phi_interp:.5f}')\n</pre> mode_name = '-2.2.0'  eta, chi_p, chi_m = 0.2, -0.1, 0.4 A_fit = hyperfit_functions[mode_name]['A'](eta, chi_p, chi_m) A_interp = hyper_interpolators[mode_name]['A'](eta, chi_p, chi_m) phi_fit = hyperfit_functions[mode_name]['phi'](eta, chi_p, chi_m) phi_interp = hyper_interpolators[mode_name]['phi'](eta, chi_p, chi_m)  print(f'A_fit: {A_fit:.5e}, A_interp: {A_interp:.5e}') print(f'phi_fit: {phi_fit:.5f}, phi_interp: {phi_interp:.5f}') <pre>A_fit: 7.61902e-05, A_interp: 1.32367e-04\nphi_fit: 5.68904, phi_interp: 5.76627\n</pre> <p>We can also interpolate the fluctuation of the mode amplitude and phase when they were extracted with our procedure</p> In\u00a0[7]: Copied! <pre>dA_interp = hyper_interpolators[mode_name]['dA'](eta, chi_p, chi_m)\ndphi_interp = hyper_interpolators[mode_name]['dphi'](eta, chi_p, chi_m)\n\nprint(f'dA_interp: {dA_interp:.5e}, dphi_interp: {dphi_interp:.5f}')\n</pre> dA_interp = hyper_interpolators[mode_name]['dA'](eta, chi_p, chi_m) dphi_interp = hyper_interpolators[mode_name]['dphi'](eta, chi_p, chi_m)  print(f'dA_interp: {dA_interp:.5e}, dphi_interp: {dphi_interp:.5f}') <pre>dA_interp: 2.87685e-05, dphi_interp: 0.23975\n</pre> In\u00a0[8]: Copied! <pre>hyperfit_functions = make_hyper_fit_functions(PN = False)\nhyper_interpolators = make_interpolators(PN = False)\n</pre> hyperfit_functions = make_hyper_fit_functions(PN = False) hyper_interpolators = make_interpolators(PN = False) In\u00a0[9]: Copied! <pre>mode_name = '2.2.1'\n\nq, chi_1, chi_2 = 2.3, 0.2, -0.2\nA_fit = hyperfit_functions[mode_name]['A'](q, chi_1, chi_2)\nA_interp = hyper_interpolators[mode_name]['A'](q, chi_1, chi_2)\nphi_fit = hyperfit_functions[mode_name]['phi'](q, chi_1, chi_2)\nphi_interp = hyper_interpolators[mode_name]['phi'](q, chi_1, chi_2)\n\nprint(f'A_fit: {A_fit:.5f}, A_interp: {A_interp:.5f}')\nprint(f'phi_fit: {phi_fit:.5f}, phi_interp: {phi_interp:.5f}')\n</pre> mode_name = '2.2.1'  q, chi_1, chi_2 = 2.3, 0.2, -0.2 A_fit = hyperfit_functions[mode_name]['A'](q, chi_1, chi_2) A_interp = hyper_interpolators[mode_name]['A'](q, chi_1, chi_2) phi_fit = hyperfit_functions[mode_name]['phi'](q, chi_1, chi_2) phi_interp = hyper_interpolators[mode_name]['phi'](q, chi_1, chi_2)  print(f'A_fit: {A_fit:.5f}, A_interp: {A_interp:.5f}') print(f'phi_fit: {phi_fit:.5f}, phi_interp: {phi_interp:.5f}') <pre>A_fit: 3.35743, A_interp: 3.38756\nphi_fit: 4.53457, phi_interp: 4.58072\n</pre>"},{"location":"notebooks/example_hyperfit_load/#load-hyperfit-functions-and-interpolator","title":"Load Hyperfit functions and interpolator\u00b6","text":"<p>In this example we will call the hyperfit functions (listed in the <code>jaxqualin</code> paper) and corresponding interpolators to estimate the amplitudes and phases of different modes, as a function of the binary black hole simulation parameters. The hyperfit polynomial terms and interpolation data might be updated in future versions of the paper.</p>"},{"location":"notebooks/example_hyperfit_load/#import-functions","title":"Import functions\u00b6","text":""},{"location":"notebooks/example_hyperfit_load/#download-data","title":"Download data\u00b6","text":"<p>By default, the download functions compares the local version of the data with the one hosted on this webpage. If the online one is newer, it will be downloaded and the local version will be overriden. Use <code>overwrite = 'force'</code> to force overwrite, and <code>never</code> to avoid overwriting.</p>"},{"location":"notebooks/example_hyperfit_load/#make-hyperfit-functions-and-interpolators","title":"Make hyperfit functions and interpolators\u00b6","text":"<p>Now we convert the downloaded data into functions and interpolators that we can easily call.</p>"},{"location":"notebooks/example_hyperfit_load/#estimating-the-amplitude-and-phase","title":"Estimating the amplitude and phase\u00b6","text":"<p>We can estimate the amplitude and phase for a set of progenitor parameters $(\\eta, \\chi_+, \\chi_-)$. All is well if the hyperfit and interpolation returns similar results.</p>"},{"location":"notebooks/example_hyperfit_load/#changing-parameterization","title":"Changing parameterization\u00b6","text":"<p>By specifying <code>PN = False</code>, we can use the $(q, \\chi_1, \\chi_2)$ parameterization instead of $(\\eta, \\chi_+, \\chi_-)$</p>"},{"location":"notebooks/example_mode_selection/","title":"Mode search","text":"In\u00a0[1]: Copied! <pre>from jaxqualin.selection import ModeSearchAllFreeVaryingNSXS\nfrom jaxqualin.utils import load_pickle_file\nfrom jaxqualin.plot import plot_mode_searcher_results\n\nimport numpy as np\n</pre> from jaxqualin.selection import ModeSearchAllFreeVaryingNSXS from jaxqualin.utils import load_pickle_file from jaxqualin.plot import plot_mode_searcher_results  import numpy as np <pre>PyCBC.libutils: pkg-config call failed, setting NO_PKGCONFIG=1\n</pre> In\u00a0[2]: Copied! <pre>settings = dict(alpha_r = 0.05, alpha_i = 0.05,\n                tau_agnostic = 10, p_agnostic = 0.95, \n                beta_A = 1.0, beta_phi = 1.5, A_tol = 1e-3,\n                tau_stable = 10, p_stable = 0.95)\n</pre> settings = dict(alpha_r = 0.05, alpha_i = 0.05,                 tau_agnostic = 10, p_agnostic = 0.95,                  beta_A = 1.0, beta_phi = 1.5, A_tol = 1e-3,                 tau_stable = 10, p_stable = 0.95) In\u00a0[3]: Copied! <pre>mode_searcher_load_pickle = False # whether or not to load the mode-searcher from a cached run\n\nSXS_num = '0305'\nl, m = 2, 2\nN_list = [3]\nt0_arr = np.linspace(0, 50, 501)\n\n# mode-searcher object\nmode_search_sxs = ModeSearchAllFreeVaryingNSXS(SXS_num, l, m, N_list = N_list, initial_num = 10, \n                                               random_initial = True, load_pickle = True,\n                                               t0_arr = t0_arr, postfix_string = 'example',\n                                               **settings)\n</pre> mode_searcher_load_pickle = False # whether or not to load the mode-searcher from a cached run  SXS_num = '0305' l, m = 2, 2 N_list = [3] t0_arr = np.linspace(0, 50, 501)  # mode-searcher object mode_search_sxs = ModeSearchAllFreeVaryingNSXS(SXS_num, l, m, N_list = N_list, initial_num = 10,                                                 random_initial = True, load_pickle = True,                                                t0_arr = t0_arr, postfix_string = 'example',                                                **settings) <pre>Skipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nSkipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/rhOverM_Asymptotic_GeometricUnits_CoM.h5\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/metadata.json\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/rhOverM_Asymptotic_GeometricUnits_CoM.h5\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/metadata.json\n</pre> In\u00a0[4]: Copied! <pre>if mode_search_sxs.pickle_exists() and mode_searcher_load_pickle:\n    file_path = mode_search_sxs.file_path\n    mode_search_sxs = load_pickle_file(file_path)\n    print('pickle loaded')\nelse:\n    mode_search_sxs.do_mode_search_varying_N()\n</pre> if mode_search_sxs.pickle_exists() and mode_searcher_load_pickle:     file_path = mode_search_sxs.file_path     mode_search_sxs = load_pickle_file(file_path)     print('pickle loaded') else:     mode_search_sxs.do_mode_search_varying_N() <pre>Runname: SXS0305_lm_2.2, making initial guesses for N_free = 3. Status:   0%|          | 0/10 [00:00&lt;?, ?it/s]</pre> <pre>Runname: SXS0305_lm_2.2, fitting for N_free = 3. Status:   0%|          | 0/501 [00:00&lt;?, ?it/s]</pre> <pre>Runname: SXS0305_lm_2.2, N_free = 3, potential modes: 2.2.1, 3.2.0, 2.2.0\nPerforming amplitude and phase flatness check for N_free = 3\n</pre> <pre>Runname: SXS0305_lm_2.2, fitting with the following modes: 2.2.1, 3.2.0, 2.2.0. Status:   0%|          | 0/501\u2026</pre> <pre>Runname: SXS0305_lm_2.2, N_free = 3, found the following 3 modes: \n2.2.1, 3.2.0, 2.2.0\nRunname: SXS0305_lm_2.2_N_3, final list of modes: \n2.2.1, 3.2.0, 2.2.0\n</pre> In\u00a0[5]: Copied! <pre>plot_mode_searcher_results(mode_search_sxs.mode_searcher_vary_N)\n</pre> plot_mode_searcher_results(mode_search_sxs.mode_searcher_vary_N)"},{"location":"notebooks/example_mode_selection/#example-mode-search-in-an-sxs-waveform","title":"Example: Mode search in an SXS waveform\u00b6","text":"<p>In this example we will be using the procedure listed out in the methods paper to search for QNMs within a waveform. The two-stage procedure starts by identifing potential modes via a frequency-agnostic fits, then checks their stability with frequency-fixed fits.</p>"},{"location":"notebooks/example_mode_selection/#import-modules","title":"Import modules\u00b6","text":""},{"location":"notebooks/example_mode_selection/#settings-for-mode-searcher-object","title":"Settings for mode-searcher object\u00b6","text":"<p>These are the default settings used in the methods paper (cf. Table I).</p>"},{"location":"notebooks/example_mode_selection/#prepare-mode-searcher-object","title":"Prepare mode-searcher object\u00b6","text":"<p><code>N_list</code> is a list of $N_f$ free QNMs to include in the frequency agnostic fit. A frequency agnoistic fit will be performed for each $N_f$ in <code>N_list</code>, and a list of potential modes will be compiled from the best run among them.</p>"},{"location":"notebooks/example_mode_selection/#run-mode-searcher","title":"Run mode-searcher\u00b6","text":"<p>If <code>mode_searcher_load_pickle</code> is <code>True</code> and a pickle file from a previous run with the same <code>postfix_string</code> exists, the mode-searcher object will load the results from it.</p>"},{"location":"notebooks/example_mode_selection/#plotting-the-results","title":"Plotting the results\u00b6","text":"<p>The left panel shows the result of the best instance of the frequency-agnostic fits among <code>N_list</code>. The center and right panels are the amplitudes and phases obtained for all the modes within the potential mode list that passed the stability test. The bolded line segments are the regions where the amplitude and phase are the flattest, and the circle marks the time at which the mode has begun to stabilize. Please consult the methods paper for the details.</p>"},{"location":"notebooks/example_summed_waveform/","title":"Summed multipoles","text":"In\u00a0[1]: Copied! <pre>from jaxqualin.waveforms import get_SXS_waveform_summed\nfrom jaxqualin.qnmode import mode_list\nfrom jaxqualin.fit import QNMFitVaryingStartingTime\nfrom jaxqualin.plot import (plot_amplitudes, plot_phases, \n                            plot_omega_free, plot_predicted_qnms)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from jaxqualin.waveforms import get_SXS_waveform_summed from jaxqualin.qnmode import mode_list from jaxqualin.fit import QNMFitVaryingStartingTime from jaxqualin.plot import (plot_amplitudes, plot_phases,                              plot_omega_free, plot_predicted_qnms)  import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>SXSnum = '0305'\niota = np.pi/3 # Cotesta's angle\npsi = np.pi/2\nh, Mf, af = get_SXS_waveform_summed(SXSnum, iota, psi, l_max=4, res=0, N_ext=2)\n</pre> SXSnum = '0305' iota = np.pi/3 # Cotesta's angle psi = np.pi/2 h, Mf, af = get_SXS_waveform_summed(SXSnum, iota, psi, l_max=4, res=0, N_ext=2) <pre>Skipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nSkipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/rhOverM_Asymptotic_GeometricUnits_CoM.h5\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/metadata.json\n</pre> In\u00a0[3]: Copied! <pre>fig, ax = plt.subplots()\nax.semilogy(h.time, np.abs(h.hr))\nax.set_xlabel(r'$t$')\nax.set_ylabel(r'$|h_r|$')\n</pre> fig, ax = plt.subplots() ax.semilogy(h.time, np.abs(h.hr)) ax.set_xlabel(r'$t$') ax.set_ylabel(r'$|h_r|$') Out[3]: <pre>Text(0, 0.5, '$|h_r|$')</pre> In\u00a0[4]: Copied! <pre>t0_arr = np.linspace(0, 50, num = 101) # array of starting times to fit for\n                                       # t0 = 0 is the peak of the strain\nqnm_fixed_list = [] # list of QNMs with fixed frequencies in the fit model\nrun_string_prefix = f\"SXS{SXSnum}_lm_2.2_iota_{iota:.7f}_psi_{psi:.7f}\" # prefix of pickle file for saving the results\nN_free = 6 # number of free modes to use\n\n# fitter object\nfitter = QNMFitVaryingStartingTime(\n                            h, t0_arr, N_free = N_free,\n                            qnm_fixed_list = qnm_fixed_list, load_pickle = True,\n                            run_string_prefix = run_string_prefix)\n</pre> t0_arr = np.linspace(0, 50, num = 101) # array of starting times to fit for                                        # t0 = 0 is the peak of the strain qnm_fixed_list = [] # list of QNMs with fixed frequencies in the fit model run_string_prefix = f\"SXS{SXSnum}_lm_2.2_iota_{iota:.7f}_psi_{psi:.7f}\" # prefix of pickle file for saving the results N_free = 6 # number of free modes to use  # fitter object fitter = QNMFitVaryingStartingTime(                             h, t0_arr, N_free = N_free,                             qnm_fixed_list = qnm_fixed_list, load_pickle = True,                             run_string_prefix = run_string_prefix) In\u00a0[5]: Copied! <pre># do fits, in series from lowest to highest starting time\n# This takes a little longer to run the first time\nfitter.do_fits()\n</pre> # do fits, in series from lowest to highest starting time # This takes a little longer to run the first time fitter.do_fits() <pre>Runname: SXS0305_lm_2.2_iota_1.0471976_psi_1.5707963, fitting for N_free = 6. Status:   0%|          | 0/101 [\u2026</pre> In\u00a0[6]: Copied! <pre># fitter results object\nresult = fitter.result_full\n</pre> # fitter results object result = fitter.result_full In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots()\n\n# mode locations to visualize on the plot\npredicted_qnms = mode_list(['2.2.0', '2.2.1', '3.2.0', '3.3.0',\n                            '2.-2.0', '3.-3.0', '4.-4.0', '4.4.0'], Mf, af)\n\nplot_omega_free(result, ax)\nplot_predicted_qnms(ax, predicted_qnms)\n</pre> fig, ax = plt.subplots()  # mode locations to visualize on the plot predicted_qnms = mode_list(['2.2.0', '2.2.1', '3.2.0', '3.3.0',                             '2.-2.0', '3.-3.0', '4.-4.0', '4.4.0'], Mf, af)  plot_omega_free(result, ax) plot_predicted_qnms(ax, predicted_qnms) In\u00a0[8]: Copied! <pre>t0_arr = np.linspace(0, 50, num = 101) # array of starting times to fit for\n                                       # t0 = 0 is the peak of the straisn\nqnm_fixed_list = mode_list(['2.2.0', '2.-2.0', '3.3.0', \n                            '3.-3.0', '4.4.0', '4.-4.0'], \n                            Mf, af) # list of QNMs with fixed frequencies in the fit model\nrun_string_prefix = f\"SXS{SXSnum}_lm_2.2_iota_{iota:.7f}_psi_{psi:.7f}\" # prefix of pickle file for saving the results\nN_free = 0 # number of free modes to use\n\n# fitter object\nfitter = QNMFitVaryingStartingTime(\n                            h, t0_arr, N_free = N_free,\n                            qnm_fixed_list = qnm_fixed_list, load_pickle = True,\n                            run_string_prefix = run_string_prefix)\n</pre> t0_arr = np.linspace(0, 50, num = 101) # array of starting times to fit for                                        # t0 = 0 is the peak of the straisn qnm_fixed_list = mode_list(['2.2.0', '2.-2.0', '3.3.0',                              '3.-3.0', '4.4.0', '4.-4.0'],                              Mf, af) # list of QNMs with fixed frequencies in the fit model run_string_prefix = f\"SXS{SXSnum}_lm_2.2_iota_{iota:.7f}_psi_{psi:.7f}\" # prefix of pickle file for saving the results N_free = 0 # number of free modes to use  # fitter object fitter = QNMFitVaryingStartingTime(                             h, t0_arr, N_free = N_free,                             qnm_fixed_list = qnm_fixed_list, load_pickle = True,                             run_string_prefix = run_string_prefix) In\u00a0[9]: Copied! <pre>fitter.do_fits()\nresult = fitter.result_full\n</pre> fitter.do_fits() result = fitter.result_full <pre>Runname: SXS0305_lm_2.2_iota_1.0471976_psi_1.5707963, fitting with the following modes: 2.2.0, 2.-2.0, 3.3.0, \u2026</pre> In\u00a0[10]: Copied! <pre>fig, axs = plt.subplots(1, 2, figsize = (12, 5))\nplot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0], \n                plot_mirror_pred = True, iota = iota, psi = psi, af = af)\nplot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1], \n            legend = False, plot_mirror_pred = True, \n            iota = iota, psi = psi, af = af)\n</pre> fig, axs = plt.subplots(1, 2, figsize = (12, 5)) plot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0],                  plot_mirror_pred = True, iota = iota, psi = psi, af = af) plot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1],              legend = False, plot_mirror_pred = True,              iota = iota, psi = psi, af = af) In\u00a0[11]: Copied! <pre>t0_arr = np.linspace(0, 50, num = 101) \nqnm_fixed_list = mode_list(['2.2.0', '3.3.0', '4.4.0'], Mf, af)\nrun_string_prefix = f\"SXS{SXSnum}_lm_2.2_iota_{iota:.7f}_psi_{psi:.7f}_incl_mirror\"\nN_free = 0\n\nfitter = QNMFitVaryingStartingTime(\n                            h, t0_arr, N_free = N_free,\n                            qnm_fixed_list = qnm_fixed_list, load_pickle = False,\n                            run_string_prefix = run_string_prefix,\n                            include_mirror = True, iota = iota, psi = psi)\n</pre> t0_arr = np.linspace(0, 50, num = 101)  qnm_fixed_list = mode_list(['2.2.0', '3.3.0', '4.4.0'], Mf, af) run_string_prefix = f\"SXS{SXSnum}_lm_2.2_iota_{iota:.7f}_psi_{psi:.7f}_incl_mirror\" N_free = 0  fitter = QNMFitVaryingStartingTime(                             h, t0_arr, N_free = N_free,                             qnm_fixed_list = qnm_fixed_list, load_pickle = False,                             run_string_prefix = run_string_prefix,                             include_mirror = True, iota = iota, psi = psi) In\u00a0[12]: Copied! <pre>fitter.do_fits()\nresult = fitter.result_full\n</pre> fitter.do_fits() result = fitter.result_full <pre>Runname: SXS0305_lm_2.2_iota_1.0471976_psi_1.5707963_incl_mirror, fitting with the following modes: 2.2.0, 3.3\u2026</pre> In\u00a0[13]: Copied! <pre>fig, axs = plt.subplots(1, 2, figsize = (12, 5))\nplot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0], plot_mirror_pred = False)\nplot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1], legend = False, plot_mirror_pred = False)\n</pre> fig, axs = plt.subplots(1, 2, figsize = (12, 5)) plot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0], plot_mirror_pred = False) plot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1], legend = False, plot_mirror_pred = False)"},{"location":"notebooks/example_summed_waveform/#example-fitting-a-waveform-with-summed-multipoles","title":"Example: Fitting a waveform with summed multipoles\u00b6","text":""},{"location":"notebooks/example_summed_waveform/#make-waveform","title":"Make waveform\u00b6","text":"<p>We will use a waveform that is a superposition of multipoles (up to <code>l_max = 4</code>) of the <code>SXS:BBH:0305</code> simulation. The observer is at the angular coordinate $(\\iota, \\psi)$.</p>"},{"location":"notebooks/example_summed_waveform/#free-qnms-unfixed-frequencies","title":"Free QNMs (unfixed frequencies)\u00b6","text":""},{"location":"notebooks/example_summed_waveform/#plotting-the-results","title":"Plotting the results\u00b6","text":"<p>We will see some of the mirror modes (modes with negative $m$) because we summed all of the multipoles</p>"},{"location":"notebooks/example_summed_waveform/#fixed-qnms-fixed-frequencies","title":"Fixed QNMs (fixed frequencies)\u00b6","text":"<p>Let us assume that the $2{,}2{,}0, 3{,}3{,}0, 4{,}4{,}0$ modes and their mirror counter-parts exist in the waveform</p>"},{"location":"notebooks/example_summed_waveform/#plotting-the-results","title":"Plotting the results\u00b6","text":"<p>Because our waveform is non-precessing, by PT symmetry, the amplitudes of the mirror modes can be predicted from those of the prograde modes, i.e. $$ \\tilde{A}_{\\ell{,}-m{,}n} = \\dfrac{S_{\\ell{,}-m{,}n}(\\iota, \\psi)}{S_{\\ell{,}m{,}n}^*(\\iota, \\psi)}\\tilde{A}^*_{\\ell{,}m{,}n} , $$ Where $\\tilde{A}$ denotes the complex amplitude, and $S_{\\ell{,}m{,}n}$ are the spin weighted ($s = -2$ in this case) spheroidal harmonics. We compute the predicted mirror mode amplitudes and plot them as dashed lines with colors corresponding to their prograde mode counter-parts.</p>"},{"location":"notebooks/example_summed_waveform/#including-a-pair-of-prograde-and-mirror-modes-as-the-same-mode","title":"Including a pair of prograde and mirror modes as the same mode\u00b6","text":"<p>Given the relationship between the complex amplitudes of the prograde and mirror modes for non-precessing mergers, we can include both modes as one mode into our fit model. This can be done with <code>include_mirror = True</code>.</p>"},{"location":"notebooks/example_summed_waveform/#plotting-the-results","title":"Plotting the results\u00b6","text":"<p>Only the amplitude of the prograde modes are shown, but the mirror modes have been included in the fit, with amplitudes fixed by PT symmetry as explained above.</p>"},{"location":"notebooks/fit_testing%20copy/","title":"Fit testing copy","text":"In\u00a0[1]: Copied! <pre>from jaxqualin.qnmode import mode, mode_list\nfrom jaxqualin.waveforms import get_waveform_SXS\nfrom jaxqualin.fit import QNMFitVaryingStartingTime\nfrom jaxqualin.plot import plot_amplitudes, plot_phases, plot_omega_free, plot_predicted_qnms\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from jaxqualin.qnmode import mode, mode_list from jaxqualin.waveforms import get_waveform_SXS from jaxqualin.fit import QNMFitVaryingStartingTime from jaxqualin.plot import plot_amplitudes, plot_phases, plot_omega_free, plot_predicted_qnms  import numpy as np import matplotlib.pyplot as plt <pre>PyCBC.libutils: pkg-config call failed, setting NO_PKGCONFIG=1\n</pre> In\u00a0[10]: Copied! <pre>type(mode_list(['2.2.0'], 1, 0.5)[0].omegai)\n</pre> type(mode_list(['2.2.0'], 1, 0.5)[0].omegai) Out[10]: <pre>jaxlib.xla_extension.ArrayImpl</pre> In\u00a0[11]: Copied! <pre>SXSnum = \"0001\"\nl = 2\nm = 2\n\nh, Mf, af, Lev = get_waveform_SXS(SXSnum, l, m)\n</pre> SXSnum = \"0001\" l = 2 m = 2  h, Mf, af, Lev = get_waveform_SXS(SXSnum, l, m) <pre>Skipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nSkipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0001v6/Lev5/rhOverM_Asymptotic_GeometricUnits_CoM.h5\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0001v6/Lev5/metadata.json\n</pre> In\u00a0[19]: Copied! <pre># h.update_peaktime(t_peak = 0)\ntype(h.hr)\n</pre> # h.update_peaktime(t_peak = 0) type(h.hr) Out[19]: <pre>jaxlib.xla_extension.ArrayImpl</pre> In\u00a0[20]: Copied! <pre>from jaxqualin.selection import ModeSearchAllFreeVaryingN\n</pre> from jaxqualin.selection import ModeSearchAllFreeVaryingN In\u00a0[13]: Copied! <pre>modesearcher = ModeSearchAllFreeVaryingN(h, Mf, af, [(2,2), (2,1), (3,3), (4,4)], N_list = [3], t0_arr = np.linspace(10, 30, 201))\n</pre> modesearcher = ModeSearchAllFreeVaryingN(h, Mf, af, [(2,2), (2,1), (3,3), (4,4)], N_list = [3], t0_arr = np.linspace(10, 30, 201)) In\u00a0[15]: Copied! <pre>modesearcher.do_mode_searches()\n</pre> modesearcher.do_mode_searches() <pre>Loaded fit Default_N_3_t0_10.0000_30.0000_201 from an old run.\nRunname: Default, N_free = 3, potential modes: constant, 2.2.0\nPerforming amplitude and phase flatness check for N_free = 3\n</pre> <pre>Runname: Default, fitting with the following modes: constant, 2.2.0. Status:   0%|          | 0/201 [00:00&lt;?, \u2026</pre> <pre>Runname: Default, N_free = 3, found the following 2 modes: \nconstant, 2.2.0\n</pre> In\u00a0[21]: Copied! <pre>from jaxqualin.qnmode import qnms_to_string\nqnms_to_string(modesearcher.found_modes_final)\n</pre> from jaxqualin.qnmode import qnms_to_string qnms_to_string(modesearcher.found_modes_final) Out[21]: <pre>['constant', '2.2.0']</pre> In\u00a0[23]: Copied! <pre>t0_arr = np.linspace(0, 50, num = 11) # array of starting times to fit for\n                                       # t0 = 0 is the peak of the strain\nqnm_fixed_list = [] # list of QNMs with fixed frequencies in the fit model\nrun_string_prefix = f\"SXS{SXSnum}_lm_{l}.{m}\" # prefix of pickle file for saving the results\nN_free = 3 # number of free modes to use\n\n# fitter object\nfitter = QNMFitVaryingStartingTime(\n                            h, t0_arr, N_free = N_free,\n                            qnm_fixed_list = qnm_fixed_list, load_pickle = True,\n                            run_string_prefix = run_string_prefix)\n</pre> t0_arr = np.linspace(0, 50, num = 11) # array of starting times to fit for                                        # t0 = 0 is the peak of the strain qnm_fixed_list = [] # list of QNMs with fixed frequencies in the fit model run_string_prefix = f\"SXS{SXSnum}_lm_{l}.{m}\" # prefix of pickle file for saving the results N_free = 3 # number of free modes to use  # fitter object fitter = QNMFitVaryingStartingTime(                             h, t0_arr, N_free = N_free,                             qnm_fixed_list = qnm_fixed_list, load_pickle = True,                             run_string_prefix = run_string_prefix) In\u00a0[24]: Copied! <pre># do fits, in series from lowest to highest starting time\n# This takes a little longer to run the first time\nfitter.do_fits()\n</pre> # do fits, in series from lowest to highest starting time # This takes a little longer to run the first time fitter.do_fits() <pre>Runname: SXS0001_lm_2.2, fitting for N_free = 3. Status:   0%|          | 0/11 [00:00&lt;?, ?it/s]</pre> In\u00a0[26]: Copied! <pre>for key in fitter.__dict__.keys():\n    print(key)\n</pre> for key in fitter.__dict__.keys():     print(key) <pre>h\nt0_arr\nN_fix\nvar_M_a\nN_free\nqnm_fixed_list\nparams0\nmax_nfev\nsequential_guess\nrun_string_prefix\nload_pickle\nfit_save_prefix\nSchwarzschild\nnonconvergence_cut\nA_bound\njcf\nfit_kwargs\ninitial_num\nrandom_initial\ninitial_dict\nA_guess_relative\nset_seed\nweighted\ndouble_skip\ninclude_mirror\niota\npsi\nmirror_ignore_phase\nmirror_ratio_list\nskip_i_init\nsave_results\nnot_converged\nnonconvergence_indx\n_time_longest\nresult_full\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[6]: Copied! <pre># fitter results object\nresult = fitter.result_full\n</pre> # fitter results object result = fitter.result_full In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots()\n\n# mode locations to visualize on the plot\npredicted_qnms = mode_list(['2.2.0', '2.2.1', '3.2.0'], Mf, af)\n\nplot_omega_free(result, ax)\nplot_predicted_qnms(ax, predicted_qnms)\n</pre> fig, ax = plt.subplots()  # mode locations to visualize on the plot predicted_qnms = mode_list(['2.2.0', '2.2.1', '3.2.0'], Mf, af)  plot_omega_free(result, ax) plot_predicted_qnms(ax, predicted_qnms) In\u00a0[8]: Copied! <pre>t0_arr = np.linspace(0, 50, num = 501) # array of starting times to fit for\n                                       # t0 = 0 is the peak of the straisn\nqnm_fixed_list = mode_list(['2.2.0', '2.2.1', '3.2.0'],\n                                   Mf, af) # list of QNMs with fixed frequencies in the fit model\nrun_string_prefix = f\"SXS{SXSnum}_lm_{l}.{m}\" # prefix of pickle file for saving the results\nN_free = 0 # number of free modes to use\n\n# fitter object\nfitter = QNMFitVaryingStartingTime(\n                            h, t0_arr, N_free = N_free,\n                            qnm_fixed_list = qnm_fixed_list, load_pickle = True,\n                            run_string_prefix = run_string_prefix)\n</pre> t0_arr = np.linspace(0, 50, num = 501) # array of starting times to fit for                                        # t0 = 0 is the peak of the straisn qnm_fixed_list = mode_list(['2.2.0', '2.2.1', '3.2.0'],                                    Mf, af) # list of QNMs with fixed frequencies in the fit model run_string_prefix = f\"SXS{SXSnum}_lm_{l}.{m}\" # prefix of pickle file for saving the results N_free = 0 # number of free modes to use  # fitter object fitter = QNMFitVaryingStartingTime(                             h, t0_arr, N_free = N_free,                             qnm_fixed_list = qnm_fixed_list, load_pickle = True,                             run_string_prefix = run_string_prefix) In\u00a0[9]: Copied! <pre>fitter.do_fits()\n</pre> fitter.do_fits() <pre>Runname: SXS0305_lm_2.2, fitting with the following modes: 2.2.0, 2.2.1, 3.2.0. Status:   0%|          | 0/501\u2026</pre> In\u00a0[10]: Copied! <pre>result = fitter.result_full\npopt_full = result.popt_full\n</pre> result = fitter.result_full popt_full = result.popt_full <p>We plot the amplitude and phase of the fixed modes, as a function of $t_0$</p> In\u00a0[11]: Copied! <pre>fig, axs = plt.subplots(1, 2, figsize = (12, 5))\nplot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0])\nplot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1], legend = False)\n</pre> fig, axs = plt.subplots(1, 2, figsize = (12, 5)) plot_amplitudes(result, fixed_modes = qnm_fixed_list, ax = axs[0]) plot_phases(result, fixed_modes = qnm_fixed_list, ax = axs[1], legend = False)"},{"location":"notebooks/fit_testing%20copy/#example-fitting-a-waveform-in-the-sxs-catalog","title":"Example: fitting a waveform in the SXS catalog\u00b6","text":""},{"location":"notebooks/fit_testing%20copy/#import-modules","title":"Import modules\u00b6","text":""},{"location":"notebooks/fit_testing%20copy/#getting-the-sxs-waveform","title":"Getting the SXS waveform\u00b6","text":"<p>The waveform will be downloaded with the <code>sxs</code> package, if not already. <code>retro</code> is <code>True</code> if $\\vec{\\chi}_{\\rm rem}$ is parallel to the orbital angular momentum of the binary and <code>False</code> if it is anti-parallel.</p>"},{"location":"notebooks/fit_testing%20copy/#case-1-fit-model-with-free-qnms-unfixed-frequencies","title":"Case 1: Fit model with free QNMs (unfixed frequencies)\u00b6","text":"<p>Here we will fit with three free QNMs ($N_{f} = 3$) and see if the resulting frequencies approach any of the QNMs we expect to find. By default, the fit results are saved with <code>pickle</code> into <code>./.jaxqualin_cache/fits/</code>. If <code>load_pickle</code> is <code>True</code>, the fitter will load the pickled result that matches <code>run_string_prefix</code> and the list of modes used.</p>"},{"location":"notebooks/fit_testing%20copy/#plotting-the-results","title":"Plotting the results\u00b6","text":"<p>Different colored points trace out the frequency evolution of a free QNM from early to late $t_0$.</p>"},{"location":"notebooks/fit_testing%20copy/#case-2-fixed-qnms-fixed-frequencies","title":"Case 2: Fixed QNMs (fixed frequencies)\u00b6","text":"<p>Here we assume that the $2{,}2{,}0, 2{,}2{,}1$ and $3{,}3{,}0$ modes are present, so we use a fit model including these three modes and fix their frequencies according to GR with the help of the <code>qnm</code> package. We will use $N_f = 0$, meaning that we do not include additional free QNMs on top of the three fixed modes.</p>"},{"location":"notebooks/mode_selection_testing%20copy/","title":"Mode selection testing copy","text":"In\u00a0[1]: Copied! <pre>from jaxqualin.selection import ModeSearchAllFreeVaryingNSXS\nfrom jaxqualin.utils import load_pickle_file\nfrom jaxqualin.plot import plot_mode_searcher_results\n</pre> from jaxqualin.selection import ModeSearchAllFreeVaryingNSXS from jaxqualin.utils import load_pickle_file from jaxqualin.plot import plot_mode_searcher_results <pre>PyCBC.libutils: pkg-config call failed, setting NO_PKGCONFIG=1\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[2]: Copied! <pre>mode_searcher_load_pickle = True # whether or not to load the mode-searcher from a cached run\n\nSXS_num = '0305'\nl, m = 2, 2\nN_list = [3]\n\n# mode-searcher object\nmode_search_sxs = ModeSearchAllFreeVaryingNSXS(SXS_num, l, m, N_list = N_list, initial_num = 10, \n                                               random_initial = True, load_pickle = True)\n</pre> mode_searcher_load_pickle = True # whether or not to load the mode-searcher from a cached run  SXS_num = '0305' l, m = 2, 2 N_list = [3]  # mode-searcher object mode_search_sxs = ModeSearchAllFreeVaryingNSXS(SXS_num, l, m, N_list = N_list, initial_num = 10,                                                 random_initial = True, load_pickle = True) <pre>Skipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nSkipping download from 'https://data.black-holes.org/catalog.json' because local file is newer\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/rhOverM_Asymptotic_GeometricUnits_CoM.h5\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/metadata.json\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/rhOverM_Asymptotic_GeometricUnits_CoM.h5\nFound the following files to load from the SXS catalog:\n    SXS:BBH:0305v5/Lev6/metadata.json\n</pre> In\u00a0[3]: Copied! <pre>if mode_search_sxs.pickle_exists() and mode_searcher_load_pickle:\n    file_path = mode_search_sxs.file_path\n    mode_search_sxs = load_pickle_file(file_path)\n    print('pickle loaded')\nelse:\n    mode_search_sxs.do_mode_search_varying_N()\n</pre> if mode_search_sxs.pickle_exists() and mode_searcher_load_pickle:     file_path = mode_search_sxs.file_path     mode_search_sxs = load_pickle_file(file_path)     print('pickle loaded') else:     mode_search_sxs.do_mode_search_varying_N() <pre>Runname: SXS0305_lm_2.2, making initial guesses for N_free = 3. Status:   0%|          | 0/10 [00:00&lt;?, ?it/s]</pre> <pre>Runname: SXS0305_lm_2.2, fitting for N_free = 3. Status:   0%|          | 0/501 [00:00&lt;?, ?it/s]</pre> <pre>Runname: SXS0305_lm_2.2, N_free = 3, potential modes: 3.2.0, 2.2.0, 2.2.1\nPerforming amplitude and phase flatness check for N_free = 3\n</pre> <pre>Runname: SXS0305_lm_2.2, fitting with the following modes: 3.2.0, 2.2.0, 2.2.1. Status:   0%|          | 0/501\u2026</pre> <pre>Runname: SXS0305_lm_2.2, N_free = 3, found the following 3 modes: \n3.2.0, 2.2.0, 2.2.1\nRunname: SXS0305_lm_2.2_N_3, final list of modes: \n3.2.0, 2.2.0, 2.2.1\n</pre> In\u00a0[9]: Copied! <pre>plot_mode_searcher_results(mode_search_sxs.mode_searcher_vary_N)\n</pre> plot_mode_searcher_results(mode_search_sxs.mode_searcher_vary_N) In\u00a0[10]: Copied! <pre>for key in mode_search_sxs.mode_searcher_vary_N.__dict__.keys():\n    print(key)\n</pre> for key in mode_search_sxs.mode_searcher_vary_N.__dict__.keys():     print(key) <pre>h\nl\nm\nM\na\nrelevant_lm_list\nt0_arr\nN_list\nkwargs\nflatness_checker_kwargs\nmode_searcher_kwargs\nmode_searchers\nfound_modes_final\nrun_string_prefix\nload_pickle\nCCE\nfixed_fitters\nflatness_checkers\nbest_run_indx\n</pre> In\u00a0[11]: Copied! <pre>for key in mode_search_sxs.__dict__.keys():\n    print(key)\n</pre> for key in mode_search_sxs.__dict__.keys():     print(key) <pre>SXSnum\nl\nm\nt0_arr\nN_list\npostfix_string\nCCE\nkwargs\nretro_def_orbit\nrelevant_lm_list_override\nrelevant_lm_list\nh\nM\na\nLev\nN_list_string\nrun_string_fitter\nrun_string\nrun_string_full\nfile_path\nload_pickle\nmode_searcher_load_pickle\nset_seed\nsave_mode_searcher\nmode_searcher_vary_N\nfound_modes_final\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/mode_selection_testing%20copy/#example-mode-search-in-an-sxs-waveform","title":"Example: Mode search in an SXS waveform\u00b6","text":"<p>In this example we will be using the procedure listed out in the methods paper to search for QNMs within a waveform. The two-stage procedure starts by identifing potential modes via a frequency-agnostic fits, then checks their stability with frequency-fixed fits.</p>"},{"location":"notebooks/mode_selection_testing%20copy/#import-modules","title":"Import modules\u00b6","text":""},{"location":"notebooks/mode_selection_testing%20copy/#prepare-mode-searcher-object","title":"Prepare mode-searcher object\u00b6","text":"<p><code>N_list</code> is a list of $N_f$ free QNMs to include in the frequency agnostic fit. A frequency agnoistic fit will be performed for each $N_f$ in <code>N_list</code>, and a list of potential modes will be compiled from the best run among them.</p>"},{"location":"notebooks/mode_selection_testing%20copy/#run-mode-searcher","title":"Run mode-searcher\u00b6","text":"<p>If <code>mode_searcher_load_pickle</code> is <code>True</code> and a pickle file from a previous run exists, the mode-searcher object will load the results from it.</p>"},{"location":"notebooks/mode_selection_testing%20copy/#plotting-the-results","title":"Plotting the results\u00b6","text":"<p>The left panel shows the result of the best instance of the frequency-agnostic fits among <code>N_list</code>. The center and right panels are the amplitudes and phases obtained for all the modes within the potential mode list that passed the stability test. The bolded line segments are the regions where the amplitude and phase are the flattest, and the circle marks the time at which the mode has begun to stabilize. Please consult the methods paper for the details.</p>"}]}